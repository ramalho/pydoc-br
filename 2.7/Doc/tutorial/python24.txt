Tutorial Python
Release 2.4.2
Guido van Rossum
Fred L. Drake, Jr., editor
Tradução: Python Brasil
23 de novembro de 2005
Python Software Foundation
Email: docs@python.org Python Brasil
http://pythonbrasil.com.br
Copyright © 2001-2004 Python Software Foundation. All rights reserved.
Copyright © 2000 BeOpen.com. All rights reserved.
Copyright © 1995-2000 Corporation for National Research Initiatives. All rights reserved.
Copyright © 1991-1995 Stichting Mathematisch Centrum. All rights reserved.
Tradução: Pedro Werneck, Osvaldo Santana Neto, José Alexandre Nalon, Felipe Lessa, Pedro de Medeiros, Rafael
Almeida, Renata Palazzo, Rodrigo Senra e outros.
Revisão: Pedro Werneck, Osvaldo Santana Neto, Pedro de Medeiros.
Veja a parte final deste documento para informações mais completas sobre licenças e permissões.
Resumo
Python é uma linguagem de programação poderosa e de fácil aprendizado. Ela possui estruturas de dados de alto-
nível eficientes, bem como adota uma abordagem simples e efetiva para a programação orientada a objetos. Sua
sintaxe elegante e tipagem dinâmica, em adição à sua natureza interpretada, tornam Python ideal para scripting e
para o desenvolvimento rápido de aplicações em diversas áreas e na maioria das plataformas.
O interpretador de Python e sua extensa biblioteca padrão estão disponíveis na forma de código fonte ou binário
para a maioria das plataformas a partir do site, http://www.python.org/, e deve ser distribuídos livremente. No
mesmo sítio estão disponíveis distribuições e referências para diversos módulos, programas, ferramentas e docu-
mentação adicional contribuídos por terceiros.
O interpretador de Python é facilmente extensível incorporando novas funções e tipos de dados implementados
em C ou C++ (ou qualquer outra linguagem acessível a partir de C). Python também se adequa como linguagem
de extensão para customizar aplicações.
Este tutorial introduz o leitor informalmente aos conceitos básicos e aspectos do sistema e linguagem Python. É
aconselhável ter um interpretador Python disponível para se poder “por a mão na massa”, porém todos os exemplos
são auto-contidos, assim o tutorial também pode ser lido sem que haja a necessidade de se estar on-line.
Para uma descrição dos módulos e objetos padrão, veja o documento Referência da Biblioteca Python. O Manual
de Referência Python oferece uma definição formal da linguagem. Para se escrever extensões em C ou C++,
leia Extendendo e Embutindo o Interpretador Python e Manual de Referência da API Python/C. Existem também
diversos livros abordando Python em maior profundidade.
Este tutorial não almeja ser abrangente ou abordar todos os aspectos, nem mesmo todos os mais frequentes. Ao
invés disso, ele introduz muitas das características dignas de nota em Python, e fornecerá a você uma boa idéia
sobre o estilo e o sabor da linguagem. Após a leitura, você deve ser capaz de ler e escrever programas e módulos
em Python, e estará pronto para aprender mais sobre os diversos módulos de biblioteca descritos na Referência da
Biblioteca Python
A tradução original do tutorial da versão 2.1 foi patrocinada pela GPr Sistemas Ltda (http://www.gpr.com.br).
A atualização do tutorial para esta versão foi realizada por voluntários do projeto PythonDoc-Brasil.
(http://www.pythonbrasil.com.br/moin.cgi/PythonDoc)
SUMÁRIO
1 Abrindo o Apetite 1
2 Utilizando o Interpretador Python 3
  2.1 Disparando o Interpretador . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
  2.2 O Interpretador e seu Ambiente . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
3 Uma Introdução Informal a Python 7
    3.1 Utilizando Python Como Uma Calculadora . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
    3.2 Primeiros Passos em Direção à Programação . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
4 Mais Ferramentas de Controle de Fluxo . . . . . . . . . . . . . . . . . . . . . . . . . 19
  4.1 Construção if . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
    4.2 Construção for . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
      4.3 A Função range() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
        4.4 Cláusulas break, continue e else em Laços . . . . . . . . . . . . . . . . . . . . . . . . . 20
          4.5 Construção pass . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
            4.6 Definindo Funções . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
                4.7 Mais sobre Definição de Funções . . . . . . . . . 23
Estruturas de Dados
5.1 Mais sobre Listas . . . . . . . . . . .
5.2 O comando del . . . . . . . . . . . .
5.3 Tuplas e Sequências . . . . . . . . . .
 5.4 Sets . . . . . . . . . . . . . . . . . .
 5.5 Dicionários . . . . . . . . . . . . . .
  5.6 Técnicas de Laço . . . . . . . . . . .
    5.7 Mais sobre Condições . . . . . . . . .
      5.8 Comparando Sequências e Outros Tipos
5
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
                                                             37
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
                                                             43
7 Entrada e Saída 47
   7.1 Refinando a Formatação de Saída . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
        7.2 Leitura e Escrita de Arquivos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
8 Erros e Exceções 53
    8.1 Erros de Sintaxe . . . . 53
    8.2 Exceções . . . . . . . . 53
      8.3 Tratamento de Exceções 54
        8.4 Levantando Exceções . 56
6
Módulos
6.1 Mais sobre Módulos
6.2 Módulos Padrão . .
6.3 A Função dir() .
6.4 Pacotes . . . . . . .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
i
8.5
8.6
9
Exceções Definidas pelo Usuário . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Definindo Ações de Limpeza . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Classes
9.1 Uma Palavra Sobre Terminologia . . . .
9.2 Escopos e Espaços de Nomes em Python
9.3 Primeiro Contato com Classes . . . . . .
9.4 Observações Aleatórias . . . . . . . . .
9.5 Herança . . . . . . . . . . . . . . . . .
9.6 Variáveis Privadas . . . . . . . . . . . .
9.7 Particularidades . . . . . . . . . . . . .
9.8 Iteradores . . . . . . . . . . . . . . . . .
9.9 Geradores . . . . . . . . . . . . . . . . .
9.10 Expressões Geradoras . . . . . . . . . .
56
58
. . . . . . . . . . . . . . . . . . . . . . 59
. . . . . . . . . . . . . . . . . . . . . . 59
. . . . . . . . . . . . . . . . . . . . . . 59
. . . . . . . . . . . . . . . . . . . . . . 61
. . . . . . . . . . . . . . . . . . . . . . 63
. . . . . . . . . . . . . . . . . . . . . . 64
. . . . . . . . . . . . . . . . . . . . . . 65
. . . . . . . . . . . . . . . . . . . . . . 66
. . . . . . . . . . . . . . . . . . . . . . 67
. . . . . . . . . . . . . . . . . . . . . . 68
                                           69
10 Um Breve Passeio Pela Biblioteca Padrão . . . . . . . . . . . . . . . . . . . . . 71
 10.1 Interface Com o Sistema Operacional . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
 10.2 Caracteres Coringa . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
 10.3 Argumentos da Linha de Comando . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
 10.4 Redirecionamento de Erros e Encerramento do Programa . . . . . . . . . . . . . . . . . . . . . . 72
 10.5 Reconhecimento de Padrões em Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
  10.6 Matemática . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
   10.7 Acesso à Internet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
    10.8 Data e Hora . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
    10.9 Compressão de Dados . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
     10.10 Medição de Desempenho . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
       10.11 Controle de Qualidade . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
       10.12 Baterias Incluídas . . . . . . . . . . . . . . . . . . . . . 75
11 Um Breve Passeio Pela Biblioteca Padrão – Parte II . . . . . . . . . . . . . . . . . . . . . 77
   11.1 Formatando Saída . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
    11.2 Templating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
    11.3 Working with Binary Data Record Layouts . . . . . . . . . . . . . . . . . . . . . . . . 79
    11.4 Multi-threading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
    11.5 Logging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
    11.6 Referências Fracas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
     11.7 Trabalhando com Listas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
     11.8 Decimal Floating Point Arithmetic . . . . . . . 82
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
12 E agora?
A Edição de Entrada Interativa e Substituição por Histórico
A.1 Edição de Linha . . . . . . . . . . . . . . . . . . . .
A.2 Substituição de Histórico . . . . . . . . . . . . . . .
A.3 Vinculação de Teclas . . . . . . . . . . . . . . . . .
A.4 Comentário . . . . . . . . . . . . . . . . . . . . . .
85
. 87
. 87
. 87
. 87
 89
B Floating Point Arithmetic: Issues and Limitations 91
B.1 Representation Error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
C History and License 95
C.1 History of the software . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
C.2 Terms and conditions for accessing or otherwise using Python . . . . . . . . . . . . . . . . . . . 96
C.3 Licenses and Acknowledgements for Incorporated Software . . . . . . . . . . . . . . . . . . . . 98
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
D Glossary 107
Índice Remissivo 111
ii
CAPÍTULO
ONE
Abrindo o Apetite
Se alguma vez você já escreveu um extenso script de shell, provavelmente se sentiu assim: você adoraria adicionar
mais uma característica, mas já está tão lento, e tão grande, e tão complicado; ou a nova característica implica
numa chamada de sistema ou função só acessível a partir do C. . . Tipicamente o problema em questão não é sério
o suficiente para motivar a re-escrita do script em C; talvez o problema exija cadeias de caracteres de comprimento
variável ou tipos (como listas ordenadas de nomes de arquivos) que são fácilmente manipuláveis na shell, porém
demandam muito esforço de implementação em C, ou talvez você nem esteja suficientemente familiarizado com
C.
Outra situação: suponha que você tenha que trabalhar com diversas bibiotecas em C, e o típico ciclo
escreve/compila/testa/re-compila seja muito lento. Você precisa desenvolver software de uma forma mais ágil.
Ou, suponha que você escreveu um programa que precise fazer uso de uma linguagem de extensão, e você não
quer projetar a linguagem, implementar e depurar um interpretador para ela, para só então estabelecer o vínculo
com sua aplicação original.
Nestes casos, Python possivelmente é exatamente do que você está precisando. Python é simples de usar, sem
deixar de ser uma linguagem de programação de verdade, oferecendo muito mais estruturação e suporte para
programas extensos do que shell scripts oferecem. Por outro lado, Python também oferece melhor verificação de
erros do que C, e por ser uma linguagem de alto nível, ela possui tipos nativos de alto nível: dicionários e vetores
(arrays) flexíveis que lhe custariam dias para obter uma implementação eficiente em C. Devido ao suporte nativo
a tipos genéricos, Python é aplicável a um domínio de problemas muito mais vasto do que Awk ou até mesmo Perl,
ainda assim Python é tão fácil de usar quanto essas linguagens sob diversos aspectos.
Python permite que você organize seu programa em módulos que podem ser reutilizados em outros programas
escritos em Python. A linguagem provê uma vasta coleção de módulos que podem ser utilizados como base para
sua aplicação — ou como exemplos para estudo e aprofundamento. Alguns desses módulos implementam manip-
ulação de arquivos, chamadas do sistema, sockets, e até mesmo acesso a bibiotecas de construção de interfaces
gráficas, como Tk.
Python é uma linguagem interpretada, que pode fazer com que você economize um tempo considerável, uma vez
que não há necessidade de compilação e vinculação(linking) durante o desenvolvimento. O interpretador pode ser
usado interativamente, o que torna fácil experimentar diversas características da linguagem, escrever programas
“descartáveis”, ou testar funções em um desenvolvimento bottom-up. É também uma útil calculadora de mesa.
Python permite a escrita de programas compactos e legíveis. Programas escritos em Python são tipicamente mais
curtos do que seus equivalentes em C ou C++, por diversas razões:
• os tipos de alto-nível permitem que você expresse operações complexas em uma único comando (statement);
• a definição de bloco é feita por indentação ao invés de marcadores de início e fim de bloco;
• não há necessidade de declaração de variáveis ou parâmetros formais;
Python é extensível: se você sabe como programar em C, é fácil adicionar funções ou módulos diretamente
no interpretador, seja para desempenhar operações críticas em máxima velocidade, ou para vincular programas
Python a bibliotecas que só estejam disponívies em formato binário (como uma bibloteca gráfica de terceiros).
Uma vez que você tenha sido fisgado, você pode vincular o interpretador Python a uma aplicação escrita em C e
utilizá-la como linguagem de comandos ou extensão para esta aplicação.
1
A propósito, a linguagem foi batizada a partir do famoso show da BBC “Monty Python's Flying Circus” e não
tem nada a ver com repulsivos répteis. Fazer referências à citações do show na documentação não é só permitido,
como também é encorajado!
Agora que você está entusiasmado com Python, vai desejar examiná-la com maior detalhe. Partindo do princípio
que a melhor maneira de aprender uma linguagem é usando-a, você está agora convidado a fazê-lo com este
tutorial.
No próximo capítulo, a mecânica de utilização do interpretador é explicada. Essa informação, ainda que mundana,
é essencial para a experimentação dos exemplos apresentados mais tarde.
O resto do tutorial introduz diversos aspectos do sistema e linguagem Python por intermédio de exemplos. Serão
abordadas expressões simples, comandos, tipos, funções e módulos. Finalmente, serão explicados alguns con-
ceitos avançados como exceções e classes definidas pelo usuário.
2
Capítulo 1. Abrindo o Apetite
CAPÍTULO
TWO
Utilizando o Interpretador Python
2.1
Disparando o Interpretador
O interpretador é freqüentemente instalado como '/usr/local/bin/python' nas máquinas em que é disponibilizado;
adicionando '/usr/local/bin' ao caminho de busca (search path) da shell de seu U NIX torna-se possível iniciá-lo
digitando:
python
na shell. Considerando que a escolha do diretório de instalação é uma opção de instalação, outras localizações são
possíveis; verifique com seu guru local de Python ou com o administrador do sistema. (Ex., '/usr/local/python' é
uma alternativa popular para instalação.)
Em computadores com Windows, Python é instalado geralmente em 'C:\Python24', apesar de você poder mudar
isso enquanto está executando o instalador. Para adicionar esse diretório ao path, você pode digitar o seguinte
comando no DOS:
set path=%path%;C:\python24
Digitando um caractere EOF() (Control-D on U NIX, Control-Z no Windows) diretamente no prompt força
o interpretador a sair com status de saída zero. Se isso não funcionar, voce pode sair do interpretador através da
digitação do seguinte: 'import sys; sys.exit()'.
As características de edição de linha não são muito sofisticadas. Sobre U NIX, seja lá quem for que tenha instalado
o interpretador talvez tenha habilitado o suporte à biblioteca readline da GNU, que adiciona facilidades mais
elaboradas de edição e histórico de comandos. Teclar Control-P no primeiro prompt oferecido pelo Python é,
provavelmente, a maneira mais rápida de verificar se a edição de linha de comando ée suportada. Se houver um
beep, você possui edição de linha de comando; veja o Apêndice A para uma introdução as teclas especiais. Se
nada acontecer, ou se ^P aparecer na tela, a opção de edição não está disponível; você apenas será capaz de usar
o backspace para remover caracteres da linha corrente.
O interpretador trabalha de forma semelhante a uma shell de U NIX: quando disparado com a saída padrão conec-
tadaa um console de terminal (tty device), ele lê e executa comandos interativamente; quando disparado com um
nome de arquivo como parâmetro ou com redirecionamento da entrada padrão para um arquivo, o interpretador
irá ler e executar o script contido em tal arquivo.
Uma segunda forma de disparar o interpretador é 'python -c command [arg] ...', que executa o(s) co-
mando(s) especificados na posição command, analogamente à opção de shell -c. Considerando que comandos
Python possuem freqüentemente espaços em branco (ou outros caracteres que sejam especiais para a shell) é
aconselhável que o comando especificado em command esteja dentro de aspas duplas.
Alguns módulos Python são também úteis como scripts. Estes podem ser chamados usando 'python -m module
[arg] ...', que executa o arquivo fonte para module como se você tivesse digitado seu caminho completo na
linha de comando.
3
Observe que há uma diferença entre 'python file' e 'python <file'. No último caso, chamadas do tipo
input() e raw_input() serão satisfeitas a partir de file. Uma vez que file já foi inteiramente lido antes de
que o script Python entrasse em execução, o programa encontrará o fim de arquivo (EOF) imediatamente. Já no
primeiro caso, que é o mais frequente (provavelmente o que você quer), a entrada de dados será fornecida pelo
dispositivo vinculado à entrada padrão do interpretador.
Quando um arquivo de script é utilizado, as vezes é útil ser capaz de executá-lo para logo em seguida entrar em
modo interativo. Este efeito pode ser obtido pela adição do parâmetro -i antes do nome do script. (Observe que
isto não irá funcionar se o script for lido a partir da entrada padrão, pelas mesmas razões explicadas no parágrafo
anterior.)
2.1.1 Passagem de Argumentos
Quando são de conhecimento do interpretador, o nome do script e subseqüentes parâmetros da linha de comando
da shell são acessíveis ao próprio script através da variável sys.argv, que é uma lista de strings. Essa lista
tem sempre ao menos um elemento; quando nenhum script ou parâmetro forem passados para o interpretador,
sys.argv[0] será uma lista vazia. Quando o nome do script for '-' (significando entrada padrão), o conteúdo
de sys.argv[0] será '-'. Quando for utilizado -c command, sys.argv[0] conterá '-c'. Quando for
utilizado -m module, sys.argv[0] conterá o caminho completo do módulo localizado. Opções especificadas
após -c command não serão consumidas pelo interpretador mas armazenadas em sys.argv.
2.1.2 Modo Interativo
Quando os comandos são lidos a partir do console (tty), diz-se que o interpretador está em modo interativo. Nesse
modo ele requisita por um próximo comando através do prompt primário, tipicamente três sinais de maior-que
('>>> '); para linhas de continuação do comando corrente, o prompt secundário default são três pontos ('... ').
O interpretador imprime uma mensagem de boas vindas, informando seu número de versão e uma nota legal de
copyright antes de oferecer o primeiro prompt:
python
Python 1.5.2b2 (#1, Feb 28 1999, 00:02:06) [GCC 2.8.1] on sunos5
Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam
>>>
Linhas de continuação são necessárias em construções multi-linha. Como exemplo, dê uma olhada nesse comando
if:
>>> o_mundo_eh_plano = 1
>>> if o_mundo_eh_plano:
...
print "Cuidado para não cair fora dele!"
...
Cuidado para não cair fora dele!
2.2
O Interpretador e seu Ambiente
2.2.1 Tratamento de Erros
Quando ocorre um erro, o interpretador imprime uma mensagem de erro e a situação da pilha (daqui em diante
stack trace). No modo interativo, retorna-se ao prompt primário; quando a entrada vem de um arquivo, o interpre-
tador aborta sua execução com status de erro diferente de zero após imprimir o stack trace (Exceções tratadas por
um except num bloco try não são consideradas erros neste contexto). Alguns erros são incondicionalmente
fatais e causam a saída com status diferente de zero; isto se aplica a inconsistências internas e alguns casos de
4
Capítulo 2. Utilizando o Interpretador Python
exaustão de memória. Todas as mensagens de erro são escritas na saída de erros padrão (standard error), enquanto
a saída dos demais comandos é direcionada para a saída padrão.
Teclando o caractere de interrupção (tipicamente Control-C ou DEL) no prompt primário ou secundário cancela a
entrada de dados corrente e retorna-se ao prompt primário. 1 Provocando uma interrupção enquanto um comando
está em execução levanta a exceção KeyboardInterrupt, a qual pode ser tratada em um bloco try.
2.2.2 Scripts Executáveis em Python
Em sistemas U NIXBSD, scripts Python podem ser transformados em executáveis, como shell scripts, pela inclusão
do cabeçalho
#! /usr/bin/env python
(Assumindo que o interpretador foi incluído do caminho de busca do usuário (PATH)) e que o script tenha a
permissão de acesso habilitada para execução. O '#!' deve estar no início do arquivo .Em algumas plataformas
esta linha inicial deve ser finalizada no estilo U NIX-style com ('\n'), ao invés do estlo Mac OS ('\r') ou mesmo
a terminação típica do Windows ('\r\n'). Observe que o caractere '#' designa comentários em Python.
Para atribuir permissão de execução (plataforma Unix) ao seu script Python, utilize o comando chmod:
$ chmod +x meuscript.py
2.2.3 Codificação em Arquivos de Código-fonte
É possível usar codificação diferente de ASCII() em arquivos de código Python. A melhor maneira de fazê-lo é
através de um comentário adicional logo após a linha #!:
# -*- coding: encoding -*-
Com essa declaração, todos os caracteres no código-fonte serão tratados como encoding, mas será possível es-
crever strings Unicode diretamente. A lista de codificações possíveis pode ser encontrada na Referência da Bib-
lioteca Python, na seção codecs.
Por exemplo, para escrever strings unicode incluindo o símbolo monetário para o Euro, ISO-8859-15 pode ser
usado, com o símbolo tendo o valor 164. Este script exibirá o valor 8364 (Unicode correspondente ao símbolo do
Euro) e retornar:
# -*- coding: iso-8859-15 -*-
currency = u" "
print ord(currency)
Se o seu editor é capaz de salvar arquivos UTF-8 com um byte order mark (conhecido como BOM), você pode
usá-lo ao invés da declaração de codificação. O IDLE é capaz de fazer isto se Options/General/Default
Source Encoding/UTF-8 estiver habilitado. Note que esta assinatura não é reconhecida por versões antigas
(Python 2.2 e anteriores), e pelo sistema operacional para arquivos com a declaração #! (usada somente em
sistemas U NIX).
Usando UTF-8 (seja através da assinatura ou de uma declaração de codificação), caracteres da maioria das línguas
do mundo podem ser usados simultaneamente em strings e comentários. Não é possível usar caracteres não-ASCII
em identificadores. Para exibir todos esses caracteres adequadamente, seu editor deve reconhecer que o arquivo é
UTF-8, e deve usar uma fonte que tenha todos os caracteres usados no arquivo.
1 Um
problema com o pacote Readline da GNU evita isso
2.2. O Interpretador e seu Ambiente
5
2.2.4 O Arquivo de Inicialização para Modo Interativo
Quando você for utilizar Python interativamente, pode ser útil adicionar uma série de comandos a serem execu-
tados por default antes de cada sessão de utilização do interpretador. Isto pode ser obtido pela configuração da
variável de ambiente PYTHONSTARTUP para indicar o nome do arquivo script que contém o script de inicial-
ização. Essa característica assemelha-se aos arquivos '.profile' de shells U NIX.
O arquivo só é processado em sessões interativas, nunca quando Python lê comandos de um script especificado
como parâmetro, nem tampouco quando '/dev/tty' é especificado como a fonte de leitura de comandos (caso
contrário se comportaria como uma sessão interativa). O script de inicialização é executado no mesmo con-
texto (doravante namespace) em que os comandos da sessão interativa serão executados, sendo assim, os objetos
definidos e módulos importados podem ser utilizados sem qualificação durante a sessão interativa. É possível
também redefinir os prompts sys.ps1 e sys.ps2 através deste arquivo.
Se for necessário ler um script adicional de inicialização a partir do diretório corrente, você pode programar
isso a partir do script de inicialização global, por exemplo 'if os.path.isfile('.pythonrc.py'):
execfile('.pythonrc.py')'. Se você deseja utilizar o script de inicialização em outro script, você deve
fazê-lo explicitamente da seguinte forma:
import os
filename = os.environ.get('PYTHONSTARTUP')
if filename and os.path.isfile(filename):
execfile(filename)
6
Capítulo 2. Utilizando o Interpretador Python
CAPÍTULO
THREE
Uma Introdução Informal a Python
Nos exemplos seguintes, pode-se distinguir a entrada da saída pela presença ou ausência dos prompts ('>>> '
and '... '): para repetir o exemplo, você deve digitar tudo após o prompt, quando o mesmo aparece; linhas que
não começarem com o prompt são na verdade as saídas geradas pelo interpretador.
Observe que existe um segundo prompt indicando a linha de continuação de um comando com múltiplas linhas, o
qual pode ser encerrado pela digitação de um linha em branco.
Muitos dos exemplos neste manual, até mesmo aqueles digitados interativamente, incluem comentários. Comen-
tários em Python são delimitados pelo caractere '#', e se extendem até o final da linha. Um comentário pode
aparecer no início da linha, depois de um espaço em branco ou código, mas nunca dentro de uma string (literal).
O delimitar de comentário dentro de uma string é interpretado como o próprio caracter.
Alguns exemplos:
# primeiro comentário
SPAM = 1
# e esse é o segundo comentário
# ... e ainda um terceiro !
STRING = "# Este não é um comentário."
3.1
Utilizando Python Como Uma Calculadora
Vamos tentar alguns comandos simples em Python. Inicie o interpretador e aguarde o prompt primário, '>>> '.
(Não deve demorar muito.)
3.1.1 Números
O interpretador atua como uma calculadora bem simples: você pode digitar uma expressão e o valor resultando
será apresentado após a avaliação da expressão. A sintaxe da expressão é a usual: operadores +, -, * e / funcionam
da mesma forma que em outras linguagens tradicionais (por exemplo, Pascal ou C); parênteses podem ser usados
para definir agrupamentos. Por exemplo:
7
>>>
4
>>>
...
4
>>>
4
>>>
5
>>>
...
2
>>>
-3
2+2
# Isso é um comentário
2+2
2+2
# e um comentário na mesma linha de um comando
(50-5*6)/4
# Divisão inteira retorna com aredondamento para base
7/3
7/-3
O sinal de igual ('=') é utilizado para atribuição de um valor a uma variável. Nenhum resultado é exibido até o
próximo prompt interativo:
>>> width = 20
>>> height = 5*9
>>> width * height
900
Um valor pode ser atribuído a diversas variáveis simultaneamente:
>>>
>>>
0
>>>
0
>>>
0
x = y = z = 0
x
# Zero x, y e z
y
z
Há total suporte para ponto-flutuante; operadores com operandos de diferentes tipos convertem o inteiro para
ponto-flutuante:
>>> 3 * 3.75 / 1.5
7.5
>>> 7.0 / 2
3.5
Números complexos também são suportados; números imaginários são escritos com o sufixo 'j' ou 'J'. Números
complexos com parte real não nula são escritos como '(real+imagj)', ou podem ser criados pela chamada de
função 'complex(real, imag)'.
8
Capítulo 3. Uma Introdução Informal a Python
>>> 1j * 1J
(-1+0j)
>>> 1j * complex(0,1)
(-1+0j)
>>> 3+1j*3
(3+3j)
>>> (3+1j)*3
(9+3j)
>>> (1+2j)/(1+1j)
(1.5+0.5j)
Números complexos são sempre representados por dois números ponto-flutuante, a parte real e a parte imaginária.
Para extrair as partes de um número z, utilize z.real e z.imag.
>>> a=1.5+0.5j
>>> a.real
1.5
>>> a.imag
0.5
As funções de conversão para ponto-flutuante e inteiro (float(), int() e long()) não funcionam para
números complexos — não existe maneira correta de converter um número complexo para um número real. Utilize
abs(z) para obter sua magnitude (como ponto-flutuante) ou z.real para obter sua parte real.
>>> a=3.0+4.0j
>>> float(a)
Traceback (most recent call last):
File "<stdin>", line 1, in ?
TypeError: can't convert complex to float; use abs(z)
>>> a.real
3.0
>>> a.imag
4.0
>>> abs(a)
5.0
No modo interativo, a última expressão a ser impressa é atribuída a variável _. Isso significa que ao utilizar Python
como uma calculadora, é muitas vezes mais fácil prosseguir com os cálculos da seguinte forma:
>>> tax = 12.5 / 100
>>> price = 100.50
>>> price * tax
12.5625
>>> price + _
113.0625
>>> round(_, 2)
113.06
Essa variável especial deve ser tratada somente para leitura pelo usuário. Nunca lhe atribua explicitamente um
valor – do contrário, estaria se criando uma outra variável (homônima) independente, que mascararia o comporta-
mento mágico da variável especial.
3.1.2 Strings
Além de números, Python também pode manipular strings, que podem ser expressas de diversas formas. Elas
podem ser delimitadas pos aspas simples ou duplas:
3.1. Utilizando Python Como Uma Calculadora
9
>>> 'spam eggs'
'spam eggs'
>>> 'doesn\'t'
"doesn't"
>>> "doesn't"
"doesn't"
>>> '"Yes," he said.'
'"Yes," he said.'
>>> "\"Yes,\" he said."
'"Yes," he said.'
>>> '"Isn\'t," she said.'
'"Isn\'t," she said.'


Strings que contém mais de uma linha podem ser construídas de diversas maneiras. Terminadores de linha podem
ser embutidos na string com barras invertidas, ex.:

oi = "Esta eh uma string longa contendo\n\
diversas linhas de texto assim como voce faria em C.\n\
Observe que os espaços em branco no inicio da linha são \
significativos."
print oi


Observe que terminadores de linha ainda precisam ser embutidos na string usando \n; a quebra de linha após a
última barra de escape seria ignorada. Este exemplo produziria o seguinte resultado:
Esta eh uma string longa contendo
diversas linhas de texto assim como voce faria em C.
Observe que os espaços em branco no inicio da linha são significativos.
No entanto, se a tornarmos uma string “crua” (raw), as sequências de \n não são convertidas para quebras de linha.
Tanto a barra invertida quanto a quebra de linha no código-fonte são incluídos na string como dados. Portanto, o
exemplo:
oi = r"Esta eh uma string longa contendo\n\
diversas linhas de texto assim como voce faria em C.\n\
Observe que os espaços em branco no inicio da linha são \
significativos."
print oi
teria como resultado:
Esta eh uma string longa contendo\n\
diversas linhas de texto assim como voce faria em C.\n\
Observe que os espaços em branco no inicio da linha são \
significativos
Ou, strings podem ser delimitadas por pares de aspas tríplices: " ou '''. Neste caso não é necessário embutir
terminadores de linha, pois o texto da string será tratado verbatim.
print """
Usage: thingy [OPTIONS]
-h
-H hostname
"""
10
Display this usage message
Hostname to connect to
Capítulo 3. Uma Introdução Informal a Python
produz a seguinte saída:
Usage: thingy [OPTIONS]
-h
-H hostname
Display this usage message
Hostname to connect to
O interpretador imprime o resultado de operações sobre strings da mesma forma que as strings são formatadas
na digitação: dentro de aspas, e com caracteres especiais embutidos em escape sequences, para mostar seu valor
com precisão. A string será delimitada por aspas duplas se ela contém um único caractere de aspas simples e
nenhum de aspas duplas, caso contrário a string será delimitada por aspas simples. ( O comando print, descrito
posteriormente, pode ser utilizado para escrever strings sem aspas ou escape sequences.)
Strings podem ser concatenadas (coladas) com o operador +, e repetidas com *:
>>> word = 'Help' + 'A'
>>> word
'HelpA'
>>> '<' + word*5 + '>'
'<HelpAHelpAHelpAHelpAHelpA>'
Duas strings literais justapostas são automaticamente concatenadas; a primeira linha do exemplo anterior poderia
ter sido escrita como 'word = 'Help”A''; isso funciona somente com strings literais, não com expressões
arbitrárias:
>>> 'str' 'ing'
'string'
>>> str.strip('str') + 'ing'
'string'
>>> str.strip('str') 'ing'
File "<stdin>", line 1
str.strip('str') 'ing'
^
SyntaxError: invalid syntax
# <- This is ok
# <- This is ok
# <- This is invalid
Strings podem ser indexadas; como em C, o primeiro índice da string é o 0. Não existe um tipo separado para
caracteres; um caractere é simplesmente uma string unitária. Assim como na linguagem Icon, substrings podem
ser especificadas através da notação slice (N.d.T: fatiar): dois índices separados por dois pontos.
>>> word[4]
'A'
>>> word[0:2]
'He'
>>> word[2:4]
'lp'
Índices de fatias slice seguem uma padronização útil; a omissão do primeiro índice equivale a zero, a omissão do
segundo índice equivale ao tamanho da string sendo fatiada.
>>> word[:2]
'He'
>>> word[2:]
'lpA'
# Os dois primeiros caracteres
# Tudo exceto os dois primeiros caracteres
Diferentemente de C, strings não podem ser alteradas em Python. Atribuir para uma posição (índice) dentro de
uma string resultará em erro:
3.1. Utilizando Python Como Uma Calculadora
11
>>> word[0] = 'x'
Traceback (most recent call last):
File "<stdin>", line 1, in ?
TypeError: object doesn't support item assignment
>>> word[:1] = 'Splat'
Traceback (most recent call last):
File "<stdin>", line 1, in ?
TypeError: object doesn't support slice assignment
Entretanto, criar uma nova string com o conteúdo combinado é fácil e eficiente:
>>> 'x' + word[1:]
'xelpA'
>>> 'Splat' + word[4]
'SplatA'
Aqui está um invariante interessante relacionado a operações de slice: s[:i] + s[i:] equals s.
>>> word[:2] + word[2:]
'HelpA'
>>> word[:3] + word[3:]
'HelpA'
Índices de slice degenerados são tratados “graciosamente” (N.d.T: este termo indica robustez no tratamento de
erros): um índice muito maior que o comprimento é trocado pelo comprimento, um limitante superior que seja
menor que o limitante inferior produz uma string vazia como resultado.
>>> word[1:100]
'elpA'
>>> word[10:]
''
>>> word[2:1]
''
Índices podem ser números negativos, para iniciar a contagem a partir da direita ao invés da esquerda. Por
exemplo:
>>> word[-1]
'A'
>>> word[-2]
'p'
>>> word[-2:]
'pA'
>>> word[:-2]
'Hel'
# O útlimo caracter
# O penúltimo caracter
# Os dois últimos caracteres
# Tudo exceto os dois últimos caracteres
Observe que -0 é o mesmo que 0, logo neste caso não se conta a partir da direita!
>>> word[-0]
'H'
# ( -0 ==
0)
Intervalos fora dos limites da string são truncados, mas não tente isso em indexações com um único índice (que
não seja um slice):
12
Capítulo 3. Uma Introdução Informal a Python
>>> word[-100:]
'HelpA'
>>> word[-10]
# error
Traceback (most recent call last):
File "<stdin>", line 1
IndexError: string index out of range
A melhor maneira de lembrar como slices funcionam é pensar nos índices como ponteiros para os espaços entre
caracteres, onde a beirada esquerda do primeiro caractere é 0. Logo a beirada direita do último caractere de uma
string de comprimento n tem índice n, por exemplo:
+---+---+---+---+---+
| H | e | l | p | A |
+---+---+---+---+---+
0
1
2
3
4
5
-5 -4 -3 -2 -1
A primeira fileira de números indica a posição dos índices 0..5 na string; a segunda fileira indica a posição dos
respectivos índices negativos. Um slice de i até j consiste em todos os caracteres entre as beiradas i e j, respecti-
vamente.
Para índices positivos, o comprimento do slice é a diferença entre os índices, se ambos estão dentro dos limites da
string, ex, o comprimento de word[1:3] é 2.
A função interna (N.d.T: interna == built-in) len() devolve o comprimento de uma string:
>>> s = 'supercalifragilisticexpialidocious'
>>> len(s)
34
See Also:
Sequências
(../lib/typesseq.html)
Strings, e strings Unicode, descritas na próxima seção, são exemplos de sequências e suportam as operações
comuns associadas com esses objetos.
Métodos de Strings
(../lib/string-methods.html)
Tanto strings comuns quanto Unicode suportam um grande número de métodos para busca e transformação.
Operações de Formatação de Strings
(../lib/typesseq-strings.html)
As operações de formatação em que strings 8-bits e Unicode são o operando à esquerda do operador % são
descritas em mais detalhes aqui.
3.1.3 Strings Unicode
A partir de Python 2.0 um novo tipo foi introduzido: o objeto Unicode. Ele pode ser usado para armazenar e
manipular dados Unicode (veja http://www.unicode.org/) e se integra bem aos demais objetos strings pré-existentes,
de forma a realizar auto-conversões quando necessário.
Unicode tem a vantagem de prover um único número ordinal para cada caractere usado em textos modernos ou
antigos. Previamente, havia somente 256 números ordinais. Logo, mapeamentos entre conjuntos de caracteres
e os 256 números ordinais precisavam ser indexados por códigos de página. Isso levou a uma enorme confusão
especialmente no âmbito da internacionalização (tipicamente escrito como 'i18n' – 'i' + 18 caracteres + 'n')
de software. Unicode resolve esses problemas ao definir um único código de página para todos os conjuntos de
caracteres.
3.1. Utilizando Python Como Uma Calculadora
13
Criar strings Unicode em Python é tão simples quanto criar strings normais:
>>> u'Hello World !'
u'Hello World !'
O pequeno 'u' antes das aspas indica a criação de uma string Unicode . Se você desejar incluir caracteres especiais
na string, você pode fazê-lo através da codificação Python Unicode-Escape.
>>> u'Hello\u0020World !'
u'Hello World !'
O código de escape \u0020 indica a inserção do caractere Unicode com valor ordinal 0x0020 (o espaço em
branco) na posição determinada.
Os outros caracteres são interpretados através de seus respectivos valores ordinais diretamente para os valores
ordinais em Unicode. Se você possui strings literais na codificação padrão Latin-1 que é utilizada na maioria
do oeste europeu, você achará conveniente que os 256 caracteres inferiores do Unicode coincidem com os 256
caracteres inferiores do Latin-1.
Para experts, existe ainda um modo cru (N.d.T: sem processamento de caracteres escape) da mesma forma que
existe para strings normais. Basta prefixar a string com 'ur' para utilizar a codificação Python Raw-Unicode-
Escape. Só será aplicado a conversão \uXXXX se houver um número ímpar de barras invertidas antes do escape
'u'.
>>> ur'Hello\u0020World !'
u'Hello World !'
>>> ur'Hello\\u0020World !'
u'Hello\\\\u0020World !'
O modo cru (N.d.T: raw) é muito útil para evitar excesso de barras invertidas, por exemplo, em expressões regu-
lares.
Além dessas codificações padrão, Python oferece um outro conjunto de maneiras de se criar strings Unicode sobre
uma codificação padrão.
A função interna unicode() provê acesso a todos os Unicode codecs registrados (COders and DECoders).
Alguns dos mais conhecidos codecs são : Latin-1, ASCII, UTF-8, and UTF-16. Os dois últimos são codificações
de tamanho variável para armazenar cada caractere Unicode em um ou mais bytes. A codificação default é ASCII,
que trata normalmente caracteres no intervalo de 0 a 127 mas rejeita qualquer outro com um erro. Quando uma
string Unicode é impressa, escrita em arquivo ou convertida por str(), a codificação padrão é utilizada.
>>> u"abc"
u'abc'
>>> str(u"abc")
'abc'
>>> u"äöü"
u'\xe4\xf6\xfc'
>>> str(u"äöü")
Traceback (most recent call last):
File "<stdin>", line 1, in ?
UnicodeEncodeError: 'ascii' codec can't encode characters in position
0-2: ordinal not in range(128)
Para se converter uma string Unicode em uma string 8-bits usando uma codificação específica, basta invocar o
método encode() de objetos Unicode passando como parâmetro o nome da codificação destino. É preferível
utilizar nomes de codificação em letras minúsculas.
14
Capítulo 3. Uma Introdução Informal a Python
>>> u"äöü".encode('utf-8')
'\xc3\xa4\xc3\xb6\xc3\xbc'
Também pode ser utilizada a função unicode() para efetuar a converção de um string em outra codificação.
Neste caso, o primeiro parâmetro é a string a ser convertida e o segundo o nome da codificação almejada. O valor
de retorno da função é a string na nova codificação.
>>> unicode('\xc3\xa4\xc3\xb6\xc3\xbc', 'utf-8')
u'\xe4\xf6\xfc'
3.1.4 Listas
Python possui diversas estruturas de dados nativas, utilizadas para agrupar outros valores. A mais versátil delas é a
lista (list), que pode ser escrita como uma lista de valores separados por vírgula e entre colchetes. Mais importante,
os valores contidos na lista não precisam ser do mesmo tipo.
>>> a = ['spam', 'eggs', 100, 1234]
>>> a
['spam', 'eggs', 100, 1234]
Da mesma forma que índices de string, índices de lista começam do 0, listas também podem ser concatenadas e
sofrer o operador de slice.
>>> a[0]
'spam'
>>> a[3]
1234
>>> a[-2]
100
>>> a[1:-1]
['eggs', 100]
>>> a[:2] + ['bacon', 2*2]
['spam', 'eggs', 'bacon', 4]
>>> 3*a[:3] + ['Boo!']
['spam', 'eggs', 100, 'spam', 'eggs', 100, 'spam', 'eggs', 100, 'Boo!']
Diferentemente de strings, que são imutáveis, é possível mudar elementos individuais da lista:
>>> a
['spam', 'eggs', 100, 1234]
>>> a[2] = a[2] + 23
>>> a
['spam', 'eggs', 123, 1234]
Atribuição à fatias (slices) é possível, e isso pode até alterar o tamanho da lista:
3.1. Utilizando Python Como Uma Calculadora
15
>>> # Replace some items:
... a[0:2] = [1, 12]
>>> a
[1, 12, 123, 1234]
>>> # Remove some:
... a[0:2] = []
>>> a
[123, 1234]
>>> # Insert some:
... a[1:1] = ['bletch', 'xyzzy']
>>> a
[123, 'bletch', 'xyzzy', 1234]
>>> a[:0] = a
# Insert (a copy of) itself at the beginning
>>> a
[123, 'bletch', 'xyzzy', 1234, 123, 'bletch', 'xyzzy', 1234]
A função interna len() também se aplica a lista:
>>> len(a)
8
É possível aninhar listas (criar listas contendo outras listas), por exemplo:
>>>
>>>
>>>
3
>>>
[2,
>>>
2
>>>
>>>
[1,
>>>
[2,
q = [2, 3]
p = [1, q, 4]
len(p)
p[1]
3]
p[1][0]
p[1].append('xtra')
p
[2, 3, 'xtra'], 4]
q
3, 'xtra']
# See section 5.1
Observe que no último exemplo, p[1] e q na verdade se referem ao mesmo objeto! Mais tarde retornaremos a
semântica do objeto.
3.2
Primeiros Passos em Direção à Programação
Naturalmente, nós podemos utilizar Python para tarefas mais complicadas do que somar dois números. A título
de exemplificação, nós podemos escrever o início da sequência de Fibonacci assim:
16
Capítulo 3. Uma Introdução Informal a Python
>>>
...
...
>>>
...
...
...
1
1
2
3
5
8
# Serie de Fibonacci :
# A soma de dois elementos define o proximo
a, b = 0, 1
while b < 10:
print b
a, b = b, a+b
Este exemplo introduz diversas características ainda não mencionadas.
• A primeira linha contém uma atribuição múltipla: as variáveis a e b simultaneamente recebem os novos
valores 0 e 1. Na última linha há outro exemplo de atribuição múltipla demonstrando que expressões do
lado direito são sempre avaliadas primeiro, antes da atribuição. As expressões do lado direito são avaliadas
da esquerda para a direita.
• O laço while executa enquanto a condição (aqui:b < 10) permanecer verdadeira. Em Python, como em
C, qualquer valor inteiro não nulo é considerado verdadeiro (valor true), zero tem valor false. A condição
pode ser ainda uma lista ou string, na verdade qualquer sequência; qualquer coisa com comprimento não
nulo tem valor true e sequências vazias tem valor false. O teste utilizado no exemplo é uma simples com-
paração. Os operadores padrão para comparação são os mesmos de C: < (menor que), > (maior que), ==
(igual), <= (menor ou igual), >= (maior ou igual) and != (diferente).
• O corpo do laço é indentado: indentação em Python é a maneira de agrupar comandos. Python (ainda!) não
possui facilidades automáticas de edição de linha. Na prática você irá preparar scripts Python complexos
em um editor de texto; a maioria dos editores de texto possui facilidades de indentação automática. Quando
comandos compostos forem alimentados ao interpretador interativamente, devem ser encerrados por uma
linha em branco (já que o parser não tem como adivinhar qual é a última linha do comando). Observe que
toda linha de um mesmo bloco de comandos deve possuir a mesma indentação.
• O comando print escreve o valor da expressão dada. Ele difere de apenas escrever a expressão no inter-
pretador (como foi feito no exemplo da calculadora) ao aceitar múltiplas expressões e strings. Strings são
impressas sem aspas, um espaço é inserido entre itens de forma a formatar o resultado assim:
>>> i = 256*256
>>> print 'The value of i is', i
The value of i is 65536
Uma vírgula ao final evita a quebra de linha:
>>> a, b = 0, 1
>>> while b < 1000:
...
print b,
...
a, b = b, a+b
...
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
Note que o interpretador insere uma quebra de linha antes de imprimir o próximo prompt se a última linha
não foi completada.
3.2. Primeiros Passos em Direção à Programação
17
18
CAPÍTULO
FOUR
Mais Ferramentas de Controle de Fluxo
Além do while recém apresentado, Python possui as estruturas usuais de controle de fluxo conhecidas em outras
linguagens, com algumas variações:
4.1
Construção if
Provavelmente uma das mais conhecidas construções é o if. Por exemplo:
>>>
>>>
...
...
...
...
...
...
...
...
...
x = int(raw_input("Por favor entre com um numero inteiro: "))
if x < 0:
x = 0
print 'Negativo mudou para zero'
elif x == 0:
print 'Zero'
elif x == 1:
print 'Um'
else:
print 'Mais'
Pode haver zero ou mais seções elif. A seção else é opcional. A palavra-chave 'elif' é uma abreviação
para 'else if', e é útil para evitar indentação excessiva. Uma sequência if . . . elif . . . elif . . . substitui as
construções switch e case encontradas em outras linguagens.
4.2
Construção for
A construção for em Python difere um pouco do que se está acostumado em C ou Pascal. Ao invés de se iterar
sobre progressões aritiméticas (como em Pascal), ou fornecer ao usuário a habilidade de definir tanto o passo da
iteração quanto a condição de parada (como em C), o for de Python itera sobre os itens de uma sequência (uma
lista ou uma string), na ordem em que aparecem na sequência. Por exemplo :
>>> # Medindo algumas strings:
... a = ['gato', 'janela', 'defenestrar']
>>> for x in a:
...
print x, len(x)
...
gato 4
janela 6
defenestrar 11
Não é seguro modificar a sequência sobre a qual se baseia o laço de iteração (isto só pode acontecer se a sequência
for mutável, isto é, uma lista). Se você precisar modificar a lista sobre a qual se está iterando, por exemplo, para
19
duplicar itens selecionados, você deve iterar sobre uma cópia da lista ao invés da própria. A notação de slice é
bastante conveniente para isso:
>>> for x in a[:]: # faz uma cópia da lista inteira
...
if len(x) > 6: a.insert(0, x)
...
>>> a
['defenestrar', 'gato', 'janela', 'defenestrar']
4.3
A Função range()
Se você precisar iterar sobre sequências numéricas, a função interna range() é a resposta. Ela gera listas
contendo progressões aritiméticas, por exemplo:
>>> range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
O ponto de parada fornecido nunca é gerado na lista; range(10) gera uma lista com 10 valores, exatamente os
índices válidos para uma sequência de comprimento 10. É possível iniciar o intervalo em outro número, ou alterar
a razão da progresão (inclusive com passo negativo):
>>> range(5, 10)
[5, 6, 7, 8, 9]
>>> range(0, 10, 3)
[0, 3, 6, 9]
>>> range(-10, -100, -30)
[-10, -40, -70]
Para iterar sobre os índices de uma sequência, combine range() e len() da seguinte forma:
>>> a = ['Mary', 'had', 'a', 'little', 'lamb']
>>> for i in range(len(a)):
...
print i, a[i]
...
0 Mary
1 had
2 a
3 little
4 lamb
4.4
Cláusulas break, continue e else em Laços
O break, como no C, quebra o laço mais interno de um for ou while.
O continue, também emprestado do C, continua o próximo passo do laço mais interno.
Laços podem ter uma cláusula else, que é executada sempre que o laço se encerra por exaustão da lista (no caso
do for) ou quando a condição se torna falsa (no caso do while), mas nunca quando o laço é encerrado por um
break. Isto é exemplificado no próximo exemplo que procura números primos:
20
Capítulo 4. Mais Ferramentas de Controle de Fluxo
>>> for n in range(2, 10):
...
for x in range(2, n):
...
if n % x == 0:
...
print n, 'equals', x, '*', n/x
...
break
...
else:
...
# loop fell through without finding a factor
...
print n, 'is a prime number'
...
2 is a prime number
3 is a prime number
4 equals 2 * 2
5 is a prime number
6 equals 2 * 3
7 is a prime number
8 equals 2 * 4
9 equals 3 * 3
4.5
Construção pass
A construção pass não faz nada. Ela pode ser usada quando a sintaxe exige um comando mas a semântica do
programa não requer nenhuma ação. Por exemplo:
>>> while True:
...
pass # Busy-wait para interrupção de teclado
...
4.6
Definindo Funções
Nós podemos criar uma função que escreve a série de Fibonacci até um limite arbitrário:
>>>
...
...
...
...
...
...
>>>
...
1 1
def fib(n):
# escreve a serie de Fibonacci ate n
"""Print a Fibonacci series up to n"""
a, b = 0, 1
while b < n:
print b,
a, b = b, a+b
# Agora invoca a funçao que acabamos de definir
fib(2000)
2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
A palavra-reservada def serve para definir uma função. Ela deve ser seguida do nome da função, da lista formal
de parâmetros entre parênteses e dois pontos.
O corpo da função deve começar na linha seguinte e deve ser indentado.

Opcionalmente, a primeira linha do corpo
da função pode ser uma string literal, cujo propósito é documentar a função. Se presente, essa string chama-se
docstring.
Existem ferramentas que utilizam docstrings para produzir automaticamente documentação impressa, on-line, ou
ainda permitir que o usuário navegue interativamente pelo código. É uma boa prárica incluir sempre docstrings
em suas funções, portanto, tente fazer disto um hábito.

A execução da função gera uma nova tabela de símbolos utilizada para as variáveis locais da função, mais pre-
cisamente, toda atribuição a variável dentro da função armazena o valor na tabela de símbolos local. Referências
4.5. Construção pass
21
a variáveis são buscadas primeiramente na tabela local, então na tabela de símbolos global e finalmente na tabela
de símbolos interna (built-in). Portanto, não se pode atribuir diretamente um valor a uma variável global den-
tro de uma função (a menos que se utilize a declaração global antes), ainda que variáveis globais possam ser
referenciadas livremente.
Os parâmetros reais (argumentos) de uma chamada de função são introduzidos na tabela de símbolos local da
função chamada, portanto, argumentos são passados por valor (onde valor é sempre uma referência para objeto,
não o valor do objeto)1 Quando uma função chama outra, uma nova tabela de símbolos é criada para tal chamada.
Uma definição de função introduz o nome da função na tabela de símbolos corrente. O valor do nome da função
possui um tipo que é reconhecido pelo interpretador como uma função definida pelo usuário. Esse valor pode ser
atribuído para outros nomes que também podem ser usados como funções. Esse mecanismo serve para renomear
funções:
>>> fib
<function fib at 10042ed0>
>>> f = fib
>>> f(100)
1 1 2 3 5 8 13 21 34 55 89
Você pode afirmar que fib não é uma função, mas um procedimento. Em Python, assim como em C, procedi-
mentos são apenas funções que não retornam valores. Na verdade, falando tecnicamente, procedimentos retornam
um valor, ainda que meio chato. Esse valor é chamado None (é um nome interno). A escrita do valor None é
supressa pelo interpretador se ele estiver sozinho. Você pode verificar isso se quiser.
>>> print fib(0)
None
É muito simples escrever uma função que retorna a lista da série de Fibonacci, ao invés de imprimi-la:
>>>
...
...
...
...
...
...
...
...
>>>
>>>
[1,
def fib2(n):
"""Retorna a lista contendo a serie de Fibonacci ate n"""
result = []
a, b = 0, 1
while b < n:
result.append(b)
# veja abaixo
a, b = b, a+b
return result
f100 = fib2(100)
# invoca
f100
# escreve resultado
1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
Este exemplo, como sempre, demonstra algumas características novas:
• A palavra-chave return termina a função retornando um valor. Se return não for seguido de nada,
então retorna o valor None. Se a função chegar ao fim sem o uso explícito do return, então também será
retornado o valor None.
• O trecho result.append(b) chama um método do objeto lista result. Um método é uma função
que pertence a um objeto e é chamada através de obj.methodname, onde obj é um objeto qualquer,
e methodname é o nome de um método que foi definido pelo tipo do objeto. Tipos diferentes definem
métodos diferentes. Sobretudo, métodos de diferentes tipos podem ser homônimos sem ambiguidade (é
possível definir seus próprios tipos de objetos e métodos, utilizando classes, como será discutido mais tarde
neste tutorial).
1 De fato, passagem por referência para objeto seria uma melhor descrição, pois quando um objeto mutável for passado, o chamador irá
perceber as alterações feitas pelo chamado (como a inserção de itens em uma lista).
22
Capítulo 4. Mais Ferramentas de Controle de Fluxo
O método append() mostrado no exemplo, é definido para todos objetos do tipo lista. Este método
permite a adição de novos elementos à lista. Neste exemplo, ele é equivalente a 'result = result +
[b]', só que append() ainda é mais eficiente.
4.7
Mais sobre Definição de Funções
Ainda é possível definir funções com um número variável de argumentos. Existem três formas que podem ser
combinadas.
4.7.1 Parâmetros com Valores Default
A mais útil das três é especificar um valor default para um ou mais argumentos. Isso cria uma função que pode
ser invocada com um número menor de argumentos do que quando foi definida.
def ask_ok(prompt, retries=4, complaint='Yes or no, please!'):
while 1:
ok = raw_input(prompt)
if ok in ('y', 'ye', 'yes'): return True
if ok in ('n', 'no', 'nop', 'nope'): return False
retries = retries - 1
if retries < 0: raise IOError, 'refusenik user'
print complaint
Essa função pode ser chamada de duas formas: ask_ok('Do you really want to quit?') ou como
ask_ok('OK to overwrite the file?', 2).
Este exemplo também introduz a keyword in, que verifica se uma sequência contém ou não um determinado
valor.
Os valores default são avaliados durante a definição da função, e no escopo em que a função foi definida:
i = 5
def f(arg = i):
print arg
i = 6
f()
irá imprimir 5.
Aviso importante: Valores default são avaliados apenas uma vez. Isso faz diferença quando o valor default é um
objeto mutável como uma lista ou dicionário. Por exemplo, a função a seguir acumula os argumentos passados
em chamadas subsequentes:
def f(a, L=[]):
L.append(a)
return L
print f(1)
print f(2)
print f(3)
Isso irá imprimir:
4.7. Mais sobre Definição de Funções
23
[1]
[1, 2]
[1, 2, 3]
Se você não quiser que o valor default seja compartilhado entre chamadas subsequentes, pode reescrever a função
assim:
def f(a, L=None):
if L is None:
L = []
L.append(a)
return L
4.7.2 Parâmetros na Forma Chave-Valor
Funções também podem ser chamadas passando argumentos no formato chave-valor como 'keyword = value'.
Por exemplo:
def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
print "-- This parrot wouldn't", action,
print "if you put", voltage, "volts through it."
print "-- Lovely plumage, the", type
print "-- It's", state, "!"
poderia ser chamada em qualquer uma das seguintes maneiras:
parrot(1000)
parrot(action = 'VOOOOOM', voltage = 1000000)
parrot('a thousand', state = 'pushing up the daisies')
parrot('a million', 'bereft of life', 'jump')
porém, existem maneiras inválidas:
parrot()
parrot(voltage=5.0, 'dead')
parrot(110, voltage=220)
parrot(actor='John Cleese')
#
#
#
#
parâmetro exigido faltando
parâmetro não-chave-valor depois de parâmetro chave-valor
valor duplicado para mesmo parâmetro
parâmetro desconhecido
Em geral, uma lista de argumentos tem que apresentar todos argumentos posicionais antes de qualquer um dos
seus argumentos chave-valor, onde as chaves têm que ser escolhidas a partir dos nomes formais dos argumentos.
Não é importante se um dado argumento já possuia valor default ou não. Nenhum argumento deve receber um
valor mais do que uma única vez. Nomes de parâmetros formais correspondendo a argumentos posicionais não
podem ser usados na forma chave-valor em uma mesma chamada. O próximo exemplo ilustra essa limitação.
>>> def function(a):
...
pass
...
>>> function(0, a=0)
Traceback (most recent call last):
File "<stdin>", line 1, in ?
TypeError: function() got multiple values for keyword argument 'a'
24
Capítulo 4. Mais Ferramentas de Controle de Fluxo
Quando o último parâmetro formal for **name, ele armazenará todos os parâmetros efetivamente passados para
a função, exceto aqueles que não correspondiam a parâmetros formais. Isto pode ser combinado com o parâmetro
formal *name (descrito na próxima sub-seção) que recebe a lista contendo todos argumentos posicionais que não
correspondiam a parâmetros formais. O importante é que (*name deve ser declarado antes de **name.) Siga o
exemplo:
def cheeseshop(kind, *arguments, **keywords):
print "-- Do you have any", kind, '?'
print "-- I'm sorry, we're all out of", kind
for arg in arguments: print arg
print '-'*40
keys = keywords.keys()
keys.sort()
for kw in keys: print kw, ':', keywords[kw]
Poderia ser chamado assim:
cheeseshop('Limburger', "It's very runny, sir.",
"It's really very, VERY runny, sir.",
client='John Cleese',
shopkeeper='Michael Palin',
sketch='Cheese Shop Sketch')
e, naturalmente, produziria:
-- Do you have any Limburger ?
-- I'm sorry, we're all out of Limburger
It's very runny, sir.
It's really very, VERY runny, sir.
----------------------------------------
client : John Cleese
shopkeeper : Michael Palin
sketch : Cheese Shop Sketch
Note que o método sort() da lista de chaves em keywords é chamado antes de exibir o conteúdo do dicionário;
se isso não fosse feito, eles seriam exibidos em ordem arbitrária.
4.7.3 Listas Arbitrárias de Argumentos
Finalmente, a opção menos frequentemente usada é chamar a função com um número arbitrário de argumentos.
Esses argumentos serão encapsulados em uma sequência (tupla). Antes do número variável de argumentos, zero
ou mais argumentos normais podem estar presentes.
def fprintf(file, format, *args):
file.write(format % args)
4.7.4 Desempacotando Listas de Argumentos
A situação inversa ocorre quando os argumentos já estão numa lista ou tupla mas é necessário que elas sejam
desempacotadas para uma chamada de função que requer argumentos separados. Por exemplo, a função range()
espera argumentos separados, start e stop. Se eles não estiverem disponíveis separadamente, escreva a chamada
de função com o operador * para retirá-los da lista ou tupla:
4.7. Mais sobre Definição de Funções
25
>>>
[3,
>>>
>>>
[3,
range(3, 6)
4, 5]
args = [3, 6]
range(*args)
4, 5]
# normal call with separate arguments
# call with arguments unpacked from a list
4.7.5 Funções Lambda
Dada a demanda do público, algumas características encontradas em linguagens de programação funcionais (como
Lisp) foram adicionadas a Python. Com a palavra-chave lambda, funções curtas e anônimas podem ser criadas.
Aqui está uma função que devolve a soma de seus dois argumentos: 'lambda a, b: a+b'.

Funções Lambda
podem ser utilizadas em qualquer lugar que exigiria uma função tradicional. Sintaticamente, funções Lambda
estão restritas a uma única expressão. Semanticamente, ela são apenas açúcar sintático para a definição de funções
normais. Assim como definições de funções aninhadas, funções lambda não podem referenciar variáveis de um
escopo mais externo:
>>>
...
...
>>>
>>>
42
>>>
43
def make_incrementor(n):
return lambda x: x + n
f = make_incrementor(42)
f(0)
f(1)
4.7.6 Strings de Documentação
Há uma convenção sobre o conteúdo e formato de strings de documentação.
A primeira linha deve ser sempre curta, representando um consiso sumário do propósito do objeto. Por brevidade,
não deve explicitamente se referir ao nome ou tipo do objeto, uma vez que estas informações estão disponívies
por outros meios (exceto se o nome da função for o próprio verbo que descreve a finalidade da função). Essa linha
deve começar com letra maiúscula e terminar com ponto.


Se existem múltiplas linhas na string de documentação, a segunda linha deve estar em branco, visulamente sepa-
rando o sumário do resto da descrição. As linhas seguintes devem conter um ou mais parágrafos descrevendo as
convenções de chamada ao objeto, seus efeitos colaterais, etc.

O parser do Python não toca na indentação de comentários multi-linha. Portanto, ferramentas que processem strings
de documentação precisam lidar com isso (se desejado). Existe uma convenção para isso. A primeira linha não
nula após a linha de sumário determina a indentação para o resto da string de documentação. A partir daí, espaços
em branco podem ser removidos de todas as linhas da string.
Aqui está um exemplo de uma docstring multi-linha:
26
Capítulo 4. Mais Ferramentas de Controle de Fluxo
>>> def my_function():
...
"""Do nothing, but document it.
...
...
No, really, it doesn't do anything.
...
"""
...
pass
...
>>> print my_function.__doc__
Do nothing, but document it.
No, really, it doesn't do anything.
4.7. Mais sobre Definição de Funções
27
28
CAPÍTULO
FIVE
Estruturas de Dados
Este capítulo descreve alguns pontos já abordados, porém com mais detalhes, e ainda adiciona outros pontos
inéditos.
5.1
Mais sobre Listas
O tipo list possui mais métodos. Aqui estão todos os métodos disponívies em um objeto lista.
append(x)
Adiciona um item ao fim da lista; equivalente a a[len(a):]
= [x].
extend(L)
Extende a lista adicionando no fim todos os elementos da lista passada como parâmetro; equivalente a
a[len(a):] = L.
insert(i, x)
Insere um item em uma posição especificada. O primeiro argumento é o índice do elemento anterior ao que
está para ser inserido, assim a.insert(0, x) insere no início da lista, e a.insert(len(a), x) é
equivalente a a.append(x).
remove(x)
Remove o primeiro item da lista cujo valor é x. É gerado um erro se este valor não existir.
pop([i ])
Remove o item na posição dada e o retorna. Se nenhum item for especificado, a.pop() remove e retorna
o último item na lista. (Os colchetes ao redor de i indicam que o parâmetro é opcional, não que você deva
digitá-los naquela posição. Você verá essa notação com frequência na Referência da Biblioteca Python.)
index(x)
Retorna o índice do primeiro item cujo valor é igual ao argumento fornecido em x, gerando erro se este
valor não existe
count(x)
Retorna o número de vezes que o valor x aparece na lista.
sort()
Ordena os itens da lista sem gerar uma nova lista.
reverse()
Inverte a ordem dos elementos na lista sem gerar uma nova lista.
Um exemplo que utiliza a maioria dos métodos:
29
>>> a = [66.25, 333, 333, 1, 1234.5]
>>> print a.count(333), a.count(66.25), a.count('x')
2 1 0
>>> a.insert(2, -1)
>>> a.append(333)
>>> a
[66.25, 333, -1, 333, 1, 1234.5, 333]
>>> a.index(333)
1
>>> a.remove(333)
>>> a
[66.25, -1, 333, 1, 1234.5, 333]
>>> a.reverse()
>>> a
[333, 1234.5, 1, 333, -1, 66.25]
>>> a.sort()
>>> a
[-1, 1, 66.25, 333, 333, 1234.5]
5.1.1 Usando Listas como Pilhas
Os métodos de lista tornam muito fácil utilizar listas como pilhas, onde o item adicionado por último é o primeiro
a ser recuperado (política “último a entrar, primeiro a sair”). Para adicionar um item ao topo da pilha, use
append(). Para recuperar um item do topo da pilha use pop() sem nenhum índice. Por exemplo:
>>>
>>>
>>>
>>>
[3,
>>>
7
>>>
[3,
>>>
6
>>>
5
>>>
[3,
stack = [3, 4, 5]
stack.append(6)
stack.append(7)
stack
4, 5, 6, 7]
stack.pop()
stack
4, 5, 6]
stack.pop()
stack.pop()
stack
4]
5.1.2 Usando Listas como Filas
Você pode também utilizar uma lista como uma fila, onde o primeiro item adicionado é o primeiro a ser recuperado
(política “primeiro a entrar, primeiro a sair”). Para adicionar um elemento ao fim da fila utiliza append(). Para
recuperar um elemento do início da fila use pop() com 0 no índice. Por exemplo:
30
Capítulo 5. Estruturas de Dados
>>> queue = ["Eric", "John", "Michael"]
>>> queue.append("Terry")
# Terry arrives
>>> queue.append("Graham")
# Graham arrives
>>> queue.pop(0)
'Eric'
>>> queue.pop(0)
'John'
>>> queue
['Michael', 'Terry', 'Graham']
5.1.3 Ferramentas para Programação Funcional
Existem três funções internas que são muito úteis sobre listas: filter(), map(), e reduce().
'filter(function, sequence)' retorna uma sequência consistindo dos itens pertencentes a sequência para os
quais function(item) é verdadeiro. If se a sequência for string ou tuple, o resultado será sempre do mesmo
tipo; caso contrário, será sempre uma lista. Por exemplo, para computar números primos:
>>> def f(x): return x % 2 != 0 and x % 3 != 0
...
>>> filter(f, range(2, 25))
[5, 7, 11, 13, 17, 19, 23]
'map(function, sequence)' aplica function(item) para cada item da sequência e retorna a lista de valores retor-
nados a cada aplicação. Por exemplo, para computar quadrados:
>>> def cube(x): return x*x*x
...
>>> map(cube, range(1, 11))
[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]
Mais de uma sequência pode ser passada; a função a ser aplicada deve possuir tantos parâmetros formais quantas
sequências forem alimentadas para 'map', e é chamada com o item correspondente de cada sequência (ou None
caso se uma sequência for menor que a outra). Se None for passado no lugar da função, então será aplicada uma
função que apenas devolve os argumentos recebidos.
>>>
>>>
...
>>>
[0,
seq = range(8)
def square(x, y): return x+y
map(add, seq, seq)
2, 4, 6, 8, 10, 12, 14]
'reduce(function, sequence)' retorna um único valor construído a partir da sucessiva aplicação da função
binária function a todos os elementos da lista fornecida, dois de cada vez. Por exemplo, para computar a soma dos
10 primeiros números inteiros:
>>> def add(x,y): return x+y
...
>>> reduce(add, range(1, 11))
55
Se apenas houver um único elemento na sequência fornecida como parâmetro, então seu valor será retornado. Se
a sequência for vazia uma exceção será levantada.
5.1. Mais sobre Listas
31
Um terceiro argumento pode ser passado para indicar o valor inicial. Neste caso, redução de sequências vazias
retornará o valor inicial. Se a sequência não for vazia, a redução se iniciará a partir do valor inicial.
>>> def sum(seq):
...
def add(x,y): return x+y
...
return reduce(add, seq, 0)
...
>>> sum(range(1, 11))
55
>>> sum([])
0
Não use este exemplo de função para somar: como somar números é uma necessidade comum, fornecemos uma
função sum(sequence) que funciona exatamente como essa. New in version 2.3.
5.1.4 Abrangência de Lista (List Comprehensions)
Abrangência de listas (ou list comprehensions) permitem a criação de listas de forma concisa sem apelar para o uso
de map(), filter() e/ou lambda. A definição resultante tende a ser mais clara do que o uso das construções
funcionais citadas anteriormente. Cada abrangência de lista consiste numa expressão seguida da cláusula for, e
então zero ou mais cláusulas for ou if. O resultado será uma lista proveniente da avaliação da expressão no
contexto das cláusulas for e if subsequentes. Se a expressão gerar uma tupla, a mesma deve ser inserida entre
parênteses.
>>> freshfruit = [' banana', ' loganberry ', 'passion fruit ']
>>> [weapon.strip() for weapon in freshfruit]
['banana', 'loganberry', 'passion fruit']
>>> vec = [2, 4, 6]
>>> [3*x for x in vec]
[6, 12, 18]
>>> [3*x for x in vec if x > 3]
[12, 18]
>>> [3*x for x in vec if x < 2]
[]
>>> [[x,x**2] for x in vec]
[[2, 4], [4, 16], [6, 36]]
>>> [x, x**2 for x in vec] # erro - parenteses requerido para tuplas
File "<stdin>", line 1 in ?
[x, x**2 for x in vec]
^
SyntaxError: invalid syntax
>>> [(x, x**2) for x in vec]
[(2, 4), (4, 16), (6, 36)]
>>> vec1 = [2, 4, 6]
>>> vec2 = [4, 3, -9]
>>> [x*y for x in vec1 for y in vec2]
[8, 6, -18, 16, 12, -36, 24, 18, -54]
>>> [x+y for x in vec1 for y in vec2]
[6, 5, -7, 8, 7, -5, 10, 9, -3]
>>> [vec1[i]*vec2[i] for i in range(len(vec1))]
[8, 12, -54]
Abrangência de listas é muito mais flexível do que map() e pode ser aplicada a expressões complexas e funções
aninhadas:
32
Capítulo 5. Estruturas de Dados
5.2
O comando del
Existe uma maneira de remover um item de uma lista a partir de seu índice, ao invés de seu valor: o comando
del. Ele difere do método pop, que retorna o item removido. Ele também pode ser utilizado para remover fatias
(slices) da lista. Por exemplo:
>>>
>>>
>>>
[1,
>>>
>>>
[1,
a = [-1, 1, 66.25, 333, 333, 1234.5]
del a[0]
a
66.25, 333, 333, 1234.5]
del a[2:4]
a
66.25, 1234.5]
del também pode ser utilizado para apagar variáveis:
>>> del a
Referenciar a variável a posteriormente a sua remoção constitui erro (pelo menos até que seja feita uma nova
atribuição para ela). Nós encontraremos outros usos para o comando del mais tarde.
5.3
Tuplas e Sequências
Nós vimos que listas e strings possuem muitas propriedades em comum como indexação e operações de slicing.
Elas são dois dos exemplos possíveis de sequências. Como Python é uma linguagem em evolução, outros tipos
de sequências podem ser adicionados. Existe ainda um outro tipo de sequência já presente na linguagem: a tupla
(tuple).
Uma tupla consiste em uma sequência imutável de valores separados por vírgulas.
>>> t = 12345, 54321, 'hello!'
>>> t[0]
12345
>>> t
(12345, 54321, 'hello!')
>>> # Tuplas podem ser aninhadas:
... u = t, (1, 2, 3, 4, 5)
>>> u
((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
Como você pode ver no trecho acima, tuplas são sempre envolvidas por parênteses. Na criação, tuplas podem ser
envolvidas ou não por parênteses, desde que o contexto não exija os parênteses (como no caso da tupla pertencer
a uma expressão maior).
Tuplas podem ser usadas de diversas formas: pares ordenados, registros de empregados em uma base de dados,
etc. Tuplas, assim como strings, são imutáveis. Não é possível atribuir valores a itens individuais de uma tupla
(você pode simular o mesmo efeito através de operações de fatiamento e concatenação). Também é possível criar
tuplas contendo objetos mutáveis, como listas.
Um problema especial é a criação de tuplas contendo 0 ou 1 itens: a sintaxe tem certos truques para acomodar
estes casos. Tuplas vazias são construídas por uma par de parênteses vazios. E uma tupla unitária é construída por
um único valor e uma vírgula entre parênteses (sem a vírgula a tupla não será gerada!). Feio, mas efetivo:
5.2. O comando del
33
>>> empty = ()
>>> singleton = 'hello',
>>> len(empty)
0
>>> len(singleton)
1
>>> singleton
('hello',)
# <-- observe a vírgula extra
O comando t = 12345, 54321, 'hello!' é um exemplo de empacotamento em tupla (tuple packing):
os valores 12345, 54321 e 'hello!' são empacotados juntos em uma tupla. A operação inversa também é
possível:
>>> x, y, z = t
Isto é chamado de desempacotamento de sequência (sequence unpacking), e requer que a lista de variáveis do lado
esquerdo corresponda ao comprimento da sequência à direita. Sendo assim, a atribuição múltipla é um caso de
empacotamento e desempacotamento de tupla.
Existe ainda uma certa assimetria aqui: empacotamento de múltiplos valores sempre cria tuplas, mas o desempa-
cotamento funciona para qualquer sequência.
5.4
Sets
Python também inclui um tipo de dados para conjuntos (sets). Um conjunto é uma coleção desordenada de
dados, sem elementos duplicados. Usos comuns para isso incluem verificações da existência de objetos em outros
sequências e eliminação de items duplicados. Conjuntos também suportam operações matemáticas como união,
interseção, diferença e diferença simétrica.
Uma pequena demonstração:
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> fruits = set(basket)
# create a set without duplicates
>>> fruits
set(['orange', 'pear', 'apple', 'banana'])
>>> 'orange' in fruits
# fast membership testing
True
>>> 'crabgrass' in fruits
False
>>> # Demonstrate set operations on unique letters from two words
...
>>> a = set('abracadabra')
>>> b = set('alacazam')
>>> a
# unique letters in a
set(['a', 'r', 'b', 'c', 'd'])
>>> a - b
# letters in a but not in b
set(['r', 'd', 'b'])
>>> a | b
# letters in either a or b
set(['a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'])
>>> a & b
# letters in both a and b
set(['a', 'c'])
>>> a ^ b
# letters in a or b but not both
set(['r', 'd', 'b', 'm', 'z', 'l'])
34
Capítulo 5. Estruturas de Dados
5.5
Dicionários
Outra estrutura de dados interna de Python, e muito útil, é o dicionário. Dicionários são também chamados de
“memória associativa”, ou “vetor associativo” . Diferentemente de sequências que são indexadas por inteiros,
dicionários são indexados por chaves (keys), que podem ser de qualquer tipo imutável (como strings e inteiros).
Tuplas também podem ser chaves se contiverem apenas strings, inteiros ou outras tuplas. Se a tupla contiver,
direta ou indiretamente, qualquer valor mutável não poderá ser chave. Listas não podem ser usadas como chaves
porque são mutáveis.
O melhor modelo mental de um dicionário é um conjunto não ordenado de pares chave-valor, onde as chaves são
únicas em uma dada instância do dicionário.
Dicionários são delimitados por : {}. Uma lista de pares chave:valor separada por vírgulas dentro desse delimita-
dores define a constituição inicial do dicionário. Dessa forma também será impresso o conteúdo de um dicionário
em uma seção de depuração.
As principais operações em um dicionário são armazenar e recuperar valores a partir de chaves. Também é possível
remover um par chave:valor com o comando del. Se você armazenar um valor utilizando uma chave já presente,
o antigo valor será substituído pelo novo. Se tentar recuperar um valor dada uma chave inexistente será gerado
um erro.
O método keys() do dicionário retorna a lista de todas as chaves presentes no dicionário, em ordem arbitrária (se
desejar ordená-las basta aplicar o método sort() na lista devolvida). Para verificar a existência de uma chave,
utilize o método has_key() do dicionário ou a keyword in.
A seguir, um exemplo de uso do dicionário:
>>> tel = {'jack': 4098, 'sape': 4139}
>>> tel['guido'] = 4127
>>> tel
{'sape': 4139, 'guido': 4127, 'jack': 4098}
>>> tel['jack']
4098
>>> del tel['sape']
>>> tel['irv'] = 4127
>>> tel
{'guido': 4127, 'irv': 4127, 'jack': 4098}
>>> tel.keys()
['guido', 'irv', 'jack']
>>> tel.has_key('guido')
True
>>> 'guido' in tel
True
A construtora dict() produz dicionários diretamente a partir de uma lista de chaves-valores, armazenadas como
tuplas. Quando os pares formam um padrão, list comprehensions podem especificar a lista de chaves-valores de
forma mais compacta.
>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
{'sape': 4139, 'jack': 4098, 'guido': 4127}
>>> dict([(x, x**2) for x in (2, 4, 6)])
# use a list comprehension
{2: 4, 4: 16, 6: 36}
Mais adiante no tutorial aprenderemos sobre Geradores, que são ainda mais adequados para fornecer os pares
chave-valor para dict().
Quando chaves são apenas strings, é mais fácil especificar os pares usando argumentos chave-valor:
>>> dict(sape=4139, guido=4127, jack=4098)
{'sape': 4139, 'jack': 4098, 'guido': 4127}
5.5. Dicionários
35
5.6
Técnicas de Laço
Ao percorrer um dicionário com um laço, a chave e o valor correspondente podem ser obtidos simultaneamente
com o método iteritems().
>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
>>> for k, v in knights.iteritems():
...
print k, v
...
gallahad the pure
robin the brave
Ao percorrer uma sequência qualquer, o índice da posição atual e o valor correspondente podem ser obtidos
simultaneamente usando a função enumerate().
>>> for i, v in enumerate(['tic', 'tac', 'toe']):
...
print i, v
...
0 tic
1 tac
2 toe
Para percorrer duas ou mais sequências simultaneamente com o laço, os items podem ser agrupados com a função
zip().
>>> questions = ['name', 'quest', 'favorite color']
>>> answers = ['lancelot', 'the holy grail', 'blue']
>>> for q, a in zip(questions, answers):
...
print 'What is your %s? It is %s.' % (q, a)
...
What is your name? It is lancelot.
What is your quest? It is the holy grail.
What is your favorite color? It is blue.
Para percorrer uma sequência em ordem reversa, chame a função reversed() com a sequência na ordem
original.
>>> for i in reversed(xrange(1,10,2)):
...
print i
...
9
7
5
3
1
Para percorrer uma sequência de maneira ordenada, use a função sorted(), que retorna uma lista ordenada com
os items, mantendo o original inalterado.
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> for f in sorted(set(basket)):
...
print f
...
apple
banana
orange
pear
36
Capítulo 5. Estruturas de Dados
5.7
Mais sobre Condições
As condições de controle utilizadas no while e if podem conter quaisquer operadores, não apenas comparações.
Os operadores de comparação in e not in verificam se um valor ocorre (ou não ocorre) em uma dada sequência.
Os operadores is e is not comparam se dois objetos são na verdade o mesmo objetos; o que só é significativo
no contexto de objetos mutáveis, como listas. Todos operadores de comparação possuem a mesma precedência,
que é menor do que a prioridade dos operadores numéricos.
Comparações podem ser encadeadas: Por exemplo a < b == c testa se a é menor que b e ainda por cima se b
é igual a c.
Comparações podem ser combinadas através de operadores booleanos and e or, e negados através de not. Estes
possuem menor prioridade que os demais operadores de comparação. Entre eles, not é o de maior prioridade e
or o de menor. Dessa forma, a condição A and not B or C é equivalente a (A and (not B)) or C.
Naturalmente, parênteses podem ser usados para expressar o agrupamento desejado.
Os operadores booleanos and and or são também operadores atalhos : seus argumentos são avaliados da esquerda
para a direita, e a avaliação pára quando o resultado se torna conhecido. Por exemplo, se A e C são verdadeiros mas
B é falso, então A and B and C não retorna a expressão C. Em geral, quando usado sobre valores genéricos e
não como booleanos, o valor de retorno de um operador atalho é o último valor avaliado na expressão.
É possível atribuir o resultado de uma comparação ou outra expressão booleana para uma variável. Por exemplo:
>>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
>>> non_null = string1 or string2 or string3
>>> non_null
'Trondheim'
Observe que em Python, diferentemente de C, atribuição não pode ocorrer dentro de uma expressão. Progra-
madores C podem resmungar, mas isso evita toda uma classe de problemas frequentemente encontrados em pro-
gramas C: digitar = numa expressão quando a intenção era ==.
5.8
Comparando Sequências e Outros Tipos
Objetos sequência podem ser comparados com outros objetos sequência, desde que o tipo das sequências seja o
mesmo. A comparação utiliza a ordem léxicografica : primeiramente os dois primeiros itens são comparados, e
se diferirem isto determinará o resultado da comparação, caso contrário os próximos dois itens serão comparados,
e assim por diante até que se tenha exaurido alguma das sequências. Se em uma comparação de itens, os mesmos
forem também sequências (aninhadas), então é disparada recursivamente outra comparação léxicografica. Se
todos os itens da sequência forem iguais, então as sequências são ditas iguais. Se uma das sequências é uma
subsequência da outra, então a subsequência é a menor (operador <). A comparação lexicográfica utiliza ASCII
para definir a ordenação. Alguns exemplos de comparações entre sequências do mesmo tipo:
(1, 2, 3)
< (1, 2, 4)
[1, 2, 3]
< [1, 2, 4]
'ABC' < 'C' < 'Pascal' < 'Python'
(1, 2, 3, 4)
< (1, 2, 4)
(1, 2)
< (1, 2, -1)
(1, 2, 3)
== (1.0, 2.0, 3.0)
(1, 2, ('aa', 'ab'))
< (1, 2, ('abc', 'a'), 4)
Observe que é permitido comparar objetos de diferentes tipos. O resultado é determinístico, porém, arbitrário: os
tipos são ordenados pelos seus nomes. Então, uma lista é sempre menor do que uma string, uma string é sempre
menor do que uma tupla, etc. 1 Tipos numéricos mistos são comparados de acordo com seus valores numéricos,
logo 0 é igual a 0.0, etc.
1 As
regras para comparação de objetos de tipos diferentes não são confiáveis; elas podem variar em futuras versões da linguagem.
5.7. Mais sobre Condições
37
38
CAPÍTULO
SIX
Módulos
Se você sair do interpretador Python e entrar novamente, todas as definições de funções e variáveis serão perdidas.
Logo, se você desejar escrever um programa que dure é melhor preparar o código em um editor de textos. Quando
estiver pronto, dispare o interpretador sobre o arquivo-fonte gerado. Isto se chama gerar um script.
A medida que seus programas crescem, pode ser desejável dividi-los em vários arquivos para facilitar a
manutenção. Talvez você até queira reutilizar uma função sem copiar sua definição a cada novo programa.
Para permitir isto, Python possui uma maneira de depositar definições em um arquivo e posteriormente reutilizá-
las em um script ou seção interativa do interpretador. Esse arquivo é denominado módulo. Definições de um
módulo podem ser importadas por outros módulos ou no módulo principal.
Um módulo é um arquivo contendo definições e comandos Python. O nome do arquivo recebe o sufixo '.py'.
Dentro de um módulo, seu nome (uma string) está disponível na variável global __name__. Por exemplo, use
seu editor de textos favorito para criar um arquivo chamado 'fibo.py' no diretório corrente com o seguinte conteúdo:
# Módulo Sequências de Fibonacci
def fib(n):
# write Fibonacci series up to n
a, b = 0, 1
while b < n:
print b,
a, b = b, a+b
def fib2(n): # return Fibonacci series up to n
result = []
a, b = 0, 1
while b < n:
result.append(b)
a, b = b, a+b
return result
Agora inicie o interpretador e importe o módulo da seguinte forma:
>>> import fibo
Isso não incorpora as funções definidas em fibo diretamente na tabela de símbolos corrente, apenas coloca o
nome do módulo lá. Através do nome do módulo você pode acessar as funções:
>>> fibo.fib(1000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
>>> fibo.fib2(100)
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
>>> fibo.__name__
'fibo'
39
Se você pretende utilizar uma função frequentemente, é possível atribuir a ela um nome local:
>>> fib = fibo.fib
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
6.1
Mais sobre Módulos
Um módulo pode conter tanto comandos como definições. Os comandos servem ao propósito de inicializar o
módulo, sendo executados apenas na primeira vez em que o mesmo é importado.1
Cada módulo possui sua própria tabela de símbolos, que é usada como tabela de símbolos global por todas as
funções definidas no próprio módulo. Portanto, o autor do módulo pode utilizar variáveis globais no módulo sem
se preocupar com colisão de nomes acindental com as variáveis globais de usuário.
Por outro lado, se você sabe o que está fazendo, é possível o acesso as variáveis globais do módulo através da
mesma notação. O que permite o acesso às funções do módulo: modname.itemname.
Módulos podem ser importados por outros módulos. É costume, porém não obrigatório, colocar todos os coman-
dos de importação (import) no início do módulo (ou script, se preferir).
Existe uma variante do comando import statement que importa nomes de um dado módulo diretamente para a
tabela do módulo importador. Os nomes do módulo importado são adicionados a tabela de símbolos global do
módulo importador. Por exemplo:
>>> from fibo import fib, fib2
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
Isso não introduz o nome do módulo importado na tabela de símbolos local, mas sim o nome da função direta-
mente.
Existe ainda uma variante que permite importar diretamente todos os nomes definidos em um dado módulo.
>>> from fibo import *
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
Isso importa todos os nomes exceto aqueles iniciados por um sublinhado (_).
6.1.1 O Caminho de Busca dos Módulos
Quando um módulo denominado spam é importado, o interpretador busca por um arquivo chamado 'spam.py'
no diretório corrente, depois na lista de diretórios especificados pela variável de ambiente PYTHONPATH. Esta
última possui a mesma sintaxe da variável de ambiente PATH, isto é, uma lista de caminhos. Quando PYTHON-
PATH não existir, ou o arquivo não for achado nesta lista, a busca continua num caminho que depende da insta-
lação. No caso do U NIX esse caminho é quase sempre '.:/usr/local/lib/python'.
De fato, módulos são buscados pela lista de caminhos especificados na variável sys.path inicializada com os
caminhos citados acima, o que permite aos programas Python manipularem o processo de busca de módulos se
desejado.
Note que devido ao fato do diretório contendo o script executado estar no caminho de busca, é importante que o
script não tenha o mesmo nome que um módulo da biblioteca padrão, ou Python vai tentar carregar o script como
1 Na verdade, definições de funções são também “comandos” que são “executados”. A execução desses comandos é colocar o nome da
função na tabela de símbolos global do módulo.
40
Capítulo 6. Módulos
tal quando aquele módulo for importado. Na maior parte das vezes essa não é a intenção e resultará em um erro.
Veja a seção 6.2,“Módulos Padrão,” para mais detalhes.
6.1.2 Arquivos Python “Compilados”
Um fator que agiliza a carga de programas curtos que utilizam muitos módulos padrão é a existência de um arquivo
com extensão '.pyc' no mesmo diretório do fonte '.py'. O arquivo '.pyc' contém uma versão “byte-compilada” do
fonte '.py'. A data de modificação de '.py' é armazenada dentro do '.pyc', e verificada automaticamente antes da
utilização do último. Se não conferir, o arquivo '.pyc' existente é re-compilado a partir do '.py' mais atual.
Normalmente, não é preciso fazer nada para gerar o arquivo '.pyc'. Sempre que um módulo '.py' é compilado com
sucesso, é feita uma tentativa de se escrever sua versão compilada para o '.pyc'. Não há geração de erro se essa
tentativa falha. Se por qualquer razão o arquivo compilado não é inteiramente escrito em disco, o '.pyc' resultante
será reconhecido como inválido e, portanto, ignorado. O conteúdo do '.pyc' é independente de plataforma, assim
um diretório de módulos Python pode ser compartilhado por diferentes arquiteturas.
Algumas dicas dos experts:
• Quando o interpretador Python é invocado com a diretiva -O, código otimizado é gerado e armazenado
em arquivos '.pyo'. O otimizador corrente não faz muita coisa, ele apenas remove construções assert
e instruções SET_LINENO. Quando o -O é utilizado, todo bytecode é otimizado. Arquivos .pyc são
ignorados e arquivos .py são compilados em bytecode otimizado.
• Passando dois flags -O ao interpretador (-OO) irá forçar o compilador de bytecode a efetuar otimizações ar-
riscadas que poderiam em casos raros acarretar o mal funcionamento de programas. Presentemente, apenas
strings __doc__ são removidas do bytecode, proporcionando arquivos '.pyo' mais compactos. Uma vez
que alguns programas podem supor a existência das docstrings, é melhor você só se utilizar disto se tiver
segurança de que não acarretará nenhum efeito colateral negativo.
• Um programa não executa mais rápido quando é lido de um arquivo '.pyc' ou de um '.pyo' em comparação
a quando é lido de um '.py'. A única diferença é que nos dois primeiros casos o tempo de carga do programa
é menor.
• Quando um script é executado diretamente a partir de seu nome da linha de comando, não são geradas as
formas compiladas deste script em arquivos '.pyo' ou '.pyc'. Portanto, o tempo de carga de um script pode
ser melhorado se transportarmos a maioria de seu código para um módulo e utilizarmos outro script apenas
para o disparo. É possível disparar o interpretador diretamente sobre arquivos compilados.
• Na presença das formas compiladas ('.pyc' e'.pyo') de um script, não há necessidade da presença da forma
textual('.py'). Isto é útil na hora de se distribuir bibliotecas Python dificultando práticas de engenharia
reversa.
• O módulo compileall pode criar arquivos '.pyc' (ou '.pyo' quando é usado -O) para todos os módulos
em um dado diretório.
6.2
Módulos Padrão
Python possui um biblioteca padrão de módulos, descrita em um documento em separado, a Python Library
Reference (doravante “Library Reference”). Alguns módulos estão embutidos no interpretador; estes possibilitam
acesso a operações que não são parte do núcleo da linguagem, seja por eficiência ou para permitir o acesso a
chamadas de sistema. O conjunto presente destes módulos é configurável, por exemplo, o módulo amoeba
só está disponível em sistemas que suportam as primitivas do Amoeba. Existe um módulo que requer especial
atenção: sys, que é embutido em qualquer interpretador Python. As variáveis sys.ps1 e sys.ps2 definem as
strings utilizadas como prompt primário e secundário:
6.2. Módulos Padrão
41
>>> import sys
>>> sys.ps1
'>>> '
>>> sys.ps2
'... '
>>> sys.ps1 = 'C> '
C> print 'Yuck!'
Yuck!
C>
Essas variáveis só estão definidas se o interpretador está em modo interativo.
A variável sys.path contém uma lista de strings que determina os caminhos de busca de módulos conhecidos
pelo interpretador. Ela é inicializada para um caminho default determinado pela variável de ambiente PYTHON-
PATH ou por um valor default interno se a variável não estiver definida. Você pode modificá-la utilizando as
operações típicas de lista, por exemplo:
>>> import sys
>>> sys.path.append('/ufs/guido/lib/python')
6.3
A Função dir()
A função interna dir() é utilizada para se descobrir que nomes são definidos por um módulo. Ela retorna uma
lista ordenada de strings:
>>> import fibo, sys
>>> dir(fibo)
['__name__', 'fib', 'fib2']
>>> dir(sys)
['__displayhook__', '__doc__', '__excepthook__', '__name__', '__stderr__',
'__stdin__', '__stdout__', '_getframe', 'api_version', 'argv',
'builtin_module_names', 'byteorder', 'callstats', 'copyright',
'displayhook', 'exc_clear', 'exc_info', 'exc_type', 'excepthook',
'exec_prefix', 'executable', 'exit', 'getdefaultencoding', 'getdlopenflags',
'getrecursionlimit', 'getrefcount', 'hexversion', 'maxint', 'maxunicode',
'meta_path', 'modules', 'path', 'path_hooks', 'path_importer_cache',
'platform', 'prefix', 'ps1', 'ps2', 'setcheckinterval', 'setdlopenflags',
'setprofile', 'setrecursionlimit', 'settrace', 'stderr', 'stdin', 'stdout',
'version', 'version_info', 'warnoptions']
Sem nenhum argumento, dir() lista os nomes atualmente definidos:
>>> a = [1, 2, 3, 4, 5]
>>> import fibo
>>> fib = fibo.fib
>>> dir()
['__builtins__', '__doc__', '__file__', '__name__', 'a', 'fib', 'fibo', 'sys']
Observe que ela lista nomes dos mais diversos tipos: variáveis, módulos, funções, etc.
dir() não lista nomes de funções ou variáveis internas. Se você desejar conhecê-los, eles estão definidos no
módulo padrão __builtin__:
42
Capítulo 6. Módulos
>>> import __builtin__
>>> dir(__builtin__)
['ArithmeticError', 'AssertionError', 'AttributeError', 'DeprecationWarning',
'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',
'FloatingPointError', 'FutureWarning', 'IOError', 'ImportError',
'IndentationError', 'IndexError', 'KeyError', 'KeyboardInterrupt',
'LookupError', 'MemoryError', 'NameError', 'None', 'NotImplemented',
'NotImplementedError', 'OSError', 'OverflowError', 'OverflowWarning',
'PendingDeprecationWarning', 'ReferenceError', 'RuntimeError',
'RuntimeWarning', 'StandardError', 'StopIteration', 'SyntaxError',
'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'True',
'TypeError', 'UnboundLocalError', 'UnicodeDecodeError',
'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError',
'UserWarning', 'ValueError', 'Warning', 'WindowsError',
'ZeroDivisionError', '_', '__debug__', '__doc__', '__import__',
'__name__', 'abs', 'apply', 'basestring', 'bool', 'buffer',
'callable', 'chr', 'classmethod', 'cmp', 'coerce', 'compile',
'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod',
'enumerate', 'eval', 'execfile', 'exit', 'file', 'filter', 'float',
'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex',
'id', 'input', 'int', 'intern', 'isinstance', 'issubclass', 'iter',
'len', 'license', 'list', 'locals', 'long', 'map', 'max', 'min',
'object', 'oct', 'open', 'ord', 'pow', 'property', 'quit', 'range',
'raw_input', 'reduce', 'reload', 'repr', 'reversed', 'round', 'set',
'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super',
'tuple', 'type', 'unichr', 'unicode', 'vars', 'xrange', 'zip']
6.4
Pacotes
Pacotes são uma maneira de estruturar espaços de nomes para módulos utilizando a sintaxe de “separação por
ponto”. Como exemplo, o módulo A.B designa um sub-módulo chamado 'B' num pacote denominado 'A'. O uso
de pacotes permite aos autores de grupos de módulos (como NumPy ou PIL) não terem que se preocupar com
colisão entre os nomes de seus módulos e os nomes de módulos de outros autores.
Suponha que você deseje projetar uma coleção de módulos (um “pacote”) para o gerenciamento uniforme de
arquivos de som. Existem muitos formatos diferentes (normalmente identificados pela extensão do nome de
arquivo, por exemplo. '.wav', '.aiff', '.au'), de forma que você pode precisar criar e manter uma crescente coleção
de módulos de conversão entre formatos. Ainda podem existir muitas operações diferentes passíveis de aplicação
sobre os arquivos de som (mixagem, eco, equalização, efeito stereo artificial). Logo, possivelmente você também
estará escrevendo uma interminável coleção de módulos para aplicar estas operações.
Aqui está uma possível estrutura para o seu pacote (expressa em termos de um sistema hierárquico de arquivos):
6.4. Pacotes
43
Sound/
__init__.py
Formats/
__init__.py
wavread.py
wavwrite.py
aiffread.py
aiffwrite.py
auread.py
auwrite.py
...
Effects/
__init__.py
echo.py
surround.py
reverse.py
...
Filters/
__init__.py
equalizer.py
vocoder.py
karaoke.py
...
Top-level package
Initialize the sound package
Subpackage for file format conversions
Subpackage for sound effects
Subpackage for filters
Ao importar esse pacote, Python busca pelo subdiretório com mesmo nome nos diretórios listados em sys.path.
Os arquivos '__init__.py' são necessários para que Python trate os diretórios como um conjunto de módulos.
Isso foi feito para evitar diretórios com nomes comuns, como 'string', de inadvertidamente esconder módulos
válidos que ocorram a posteriori no caminho de busca. No caso mais simples, '__init__.py' pode ser um arquivo
vazio. Porém, ele pode conter código de inicialização para o pacote ou gerar a variável __all__, que será
descrita depois.
Usuários do pacote podem importar módulos individuais, por exemplo:
import Sound.Effects.echo
Assim se carrega um sub-módulo Sound.Effects.echo. Ele deve ser referenciado com seu nome completo,
como em:
Sound.Effects.echo.echofilter(input, output, delay=0.7, atten=4)
Uma alternativa para a importação é:
from Sound.Effects import echo
Assim se carrega o módulo sem necessidade de prefixação na hora do uso. Logo, pode ser utilizado como se
segue:
echo.echofilter(input, output, delay=0.7, atten=4)
Também é possível importar diretamente uma única variável ou função, como em:
from Sound.Effects.echo import echofilter
Novamente, há carga do sub-módulo echo, mas a função echofilter() está acessível diretamente sem pre-
fixação:
44
Capítulo 6. Módulos
echofilter(input, output, delay=0.7, atten=4)
Observe que ao utilizar from package import item, o item pode ser um sub-pacote, sub-módulo, classe,
função ou variável. O comando import primeiro testa se o item está definido no pacote, senão assume que é um
módulo e tenta carregá-lo. Se falhar em encontrar o módulo uma exceção ImportError é levantada.
Em oposição, na construção import item.subitem.subsubitem, cada item, com exceção do último, deve ser um
pacote. O último pode ser também um pacote ou módulo, mas nunca uma entidade contida em um módulo.
6.4.1 Importando * de Um Pacote
Agora, o que acontece quando um usuário escreve from Sound.Effects import * ? Idealmente, poderia
se esperar que todos sub-módulos presentes no pacote fossem importados. Infelizmente, essa operação não fun-
ciona muito bem nas plataformas Mac ou Windows, onde não existe distinção entre maiúsculas ou minúsculas nos
sistema de arquivos. Nestas plataformas não há como saber como importar o arquivo 'ECHO.PY', deveria ser com
o nome echo, Echo ou ECHO (por exemplo, o Windows 95 tem o irritante hábito de colocar a primeira letra em
maiúscula). A restrição de nomes de arquivo em DOS com o formato 8+3 adiciona um outro problema na hora de
se utilizar arquivos com nomes longos.
A única solução é o autor do pacote fornecer um índice explícito do pacote. O comando de importação utiliza a
seguinte convenção: se o arquivo '__init__.py' do pacote define a lista chamada __all__, então esta lista indica
os nomes dos módulos a serem importados quando o comando from package import * é encontrado.
Fica a cargo do autor do pacote manter esta lista atualizada, inclusive fica a seu critério excluir inteiramente o
suporte a importação direta de todo o pacote através do from package import *. Por exemplo, o arquivo
'Sounds/Effects/__init__.py' poderia conter apenas:
__all__ = ["echo", "surround", "reverse"]
Isso significaria que from Sound.Effects import * iria importar apenas os três sub-módulos especifica-
dos no pacote Sound.
Se __all__ não estiver definido, o comando from Sound.Effects import * não importará todos os
sub-módulos do pacote Sound.Effects no espaço de nomes corrente. Há apenas garantia que o pacote
Sound.Effects foi importado (possivelmente executando qualquer código de inicialização em '__init__.py')
juntamente com os nomes definidos no pacote. Isso inclui todo nome definido em '__init__.py' bem como em
qualquer sub-módulo importado a partir deste. Considere o código abaixo:
import Sound.Effects.echo
import Sound.Effects.surround
from Sound.Effects import *
Neste exemplo, os módulos echo e surround são importados no espaço de nomes corrente, pois estão definidos no
pacote Sound.Effects. O que também funciona quando __all__ estiver definida.
Em geral, a prática de importar * de um dado módulo é desaconselhada, principalmente por prejudicar a legibili-
dade do código. Contudo, é recomendada em sessões interativas para evitar excesso de digitação.
Lembre-se que não há nada de errado em utilizar from Package import specific_submodule! De
fato, essa é a notação recomendada a menos que o módulo efetuando a importação precise utilizar sub-módulos
homônimos em diferentes pacotes.
6.4.2 Referências em Um Mesmo Pacote
Os sub-módulos frequentemente precisam referenciar uns aos outros. Por exemplo, o módulo surround talvez
precise utilizar o módulo echo. De fato, tais referências são tão comuns que o comando import primeiro busca
6.4. Pacotes
45
módulos dentro do pacote antes de utilizar o caminho de busca padrão. Portanto, o módulo surround pode
usar simplesmente import echo ou from echo import echofilter. Se o módulo importado não for
encontrado no pacote corrente (o pacote do qual o módulo corrente é sub-módulo), então o comando import
procura por um módulo de mesmo nome no escopo global.
Quando pacotes são estruturados em sub-pacotes (como no exemplo Sound), não existe atalho para referenciar
sub-módulos de pacotes irmãos - o nome completo do pacote deve ser utilizado. Por exemplo, se o módulo
Sound.Filters.vocoder precisa utilizar o módulo echo no pacote Sound.Effects, é preciso importá-
lo como from Sound.Effects import echo.
6.4.3 Packages in Multiple Directories
Pacotes suportam mais um atributo especiai, __path__. Este é inicializado como uma lista contendo o nome
do diretório com o arquivo '__init__.py' do pacote, antes do código naquele arquivo ser executado. Esta variável
pode ser modificada; isso afeta a busca futura de módulos e subpacotes contidos no pacote.
Apesar de não ser muito usado, pode ser usado para extender o conjunto de módulos usado num pacote.
46
Capítulo 6. Módulos
CAPÍTULO
SEVEN
Entrada e Saída
Existem diversas maneiras de se apresentar a saída de um programa. Dados podem ser impressos em forma imedi-
atamente legível, ou escritos em um arquivo para uso futuro. Este capítulo vai discutir algumas das possibilidades.
7.1
Refinando a Formatação de Saída
Até agora nós encontramos duas maneiras de escrever valores: através de expressões e pelo comando print
(uma terceira maneira é utilizar o método write() de objetos de arquivo; a saída padrão pode ser referenciada
como sys.stdout). Veja o documento Library Reference para mais informações sobre este tópico.

Frequentemente você desejará mais controle sobre a formatação de saída do que simplesmente imprimindo valores
separados por espaços. Existem duas formas. A primeira é você mesmo manipular a string através de recortes
(slicing) e concatenação. O módulo padrão string contém algumas rotinas úteis a esta finalidade. A segunda
maneira é utilizar o operador %.
O operador % interpreta seu argumento à esquerda como uma string de formatação de um sprintf() aplicada
ao argumento à direita do operador. O resultado é uma string formatada.
Permanece a questão: como converter valores para strings? Por sorte, Python possui maneiras de converter qual-
quer valor para uma string: basta submetê-lo a função repr() ou str(). Aspas reversas (“) são equivalentes
a repr(), mas não são mais usadas com frequência e provavelmente serão retiradas de futuras versões da lin-
guagem.
47
>>> s = 'Hello, world.'
>>> str(s)
'Hello, world.'
>>> repr(s)
"'Hello, world.'"
>>> str(0.1)
'0.1'
>>> repr(0.1)
'0.10000000000000001'
>>> x = 10 * 3.25
>>> y = 200 * 200
>>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'
>>> print s
The value of x is 32.5, and y is 40000...
>>> # The repr() of a string adds string quotes and backslashes:
... hello = 'hello, world\n'
>>> hellos = repr(hello)
>>> print hellos
'hello, world\n'
>>> # The argument to repr() may be any Python object:
... repr((x, y, ('spam', 'eggs')))
"(32.5, 40000, ('spam', 'eggs'))"
>>> # reverse quotes are convenient in interactive sessions:
... 'x, y, ('spam', 'eggs')'
"(32.5, 40000, ('spam', 'eggs'))"
A seguir, duas maneiras de se escrever uma tabela de quadrados e cubos:
>>> for x in range(1, 11):
...
print repr(x).rjust(2), repr(x*x).rjust(3),
...
# Observe a vírgula final na linha anterior
...
print repr(x*x*x).rjust(4)
...
1
1
1
2
4
8
3
9
27
4 16
64
5 25 125
6 36 216
7 49 343
8 64 512
9 81 729
10 100 1000
>>> for x in range(1,11):
...
print '%2d %3d %4d' % (x, x*x, x*x*x)
...
1
1
1
2
4
8
3
9
27
4 16
64
5 25 125
6 36 216
7 49 343
8 64 512
9 81 729
10 100 1000
Note que os espaços adicionados entre as colunas se devem a forma de funcionamento do comando print : ele
sempre adiciona espaço entre seus argumentos.
Este exemplo demonstra o método rjust() de strings, que justifica uma string à direita gerando espaços adi-
cionais à esquerda. Existem métodos análogas ljust() e center(). Esses métodos apenas retornam a string

formatada. Se a entrada extrapolar o comprimento exigido a string original é devolvida sem modificação. A razão
para isso é não apresentar um valor potencialmente corrompido por truncamento (se for desejado truncar o valor
pode-se utilizar operações de recorte como em 'x.ljust(n)[0:n]').
Existe ainda o método zfill() que preenche uma string numérica com zeros à esquerda. Ele entende sinais
positivos e negativos.
>>> '12'.zfill(5)
'00012'
>>> '-3.14'.zfill(7)
'-003.14'
>>> '3.14159265359'.zfill(5)
'3.14159265359'
Um exemplo de uso do operador %:
>>> import math
>>> print 'The value of PI is approximately %5.3f.' % math.pi
The value of PI is approximately 3.142.
Se há mais do que um formato, então o argumento à direita deve ser uma tupla com os valores de formatação.
Exemplo:
>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
>>> for name, phone in table.items():
...
print '%-10s ==> %10d' % (name, phone)
...
Jack
==>
4098
Dcab
==>
7678
Sjoerd
==>
4127
A maioria dos formatos funciona da mesma maneira que em C, e exigem que você passe o tipo apropriado.
Entretanto, em caso de erro ocorre uma exceção e não uma falha do sistema operacional. O formato %s é mais
relaxado: se o argumento correspondente não for um objeto string, então ele é convertido para string pela função
interna str().
Há suporte para o modificador * determinar o comprimento ou precisão num argumento inteiro em separado. Os
formatadores (em C) %n e %p também são suportados.
Se você possuir uma string de formatação muito longa, seria bom referenciar as variáveis de formatação por nome,
ao invés de por posição. Isso pode ser obtido passando um dicionário como argumento à direita e prefixando
campos na string de formatação com %(name)format. Veja o exermplo:
>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
>>> print 'Jack: %(Jack)d; Sjoerd: %(Sjoerd)d; Dcab: %(Dcab)d' % table
Jack: 4098; Sjoerd: 4127; Dcab: 8637678
Isso é particularmente útil em combinação com a nova função interna vars(), que retorna um dicionário con-
tendo todas as variáveis locais.
7.2
Leitura e Escrita de Arquivos
A função open() retorna um objeto de arquivo, e é frequentemente usada com dois argumentos:
'open(filename, mode)'.
7.2. Leitura e Escrita de Arquivos
49
>>> f=open('/tmp/workfile', 'w')
>>> print f
<open file '/tmp/workfile', mode 'w' at 80a0960>
O primeiro argumento é uma string contendo o nome do arquivo. O segundo argumento é outra string contendo
alguns caracteres que descrevem o modo como o arquivo será usado. O parâmetro mode pode assumir valor 'r'
quando o arquivo será só de leitura, 'w' quando for só de escrita (se o arquivo já existir seu conteúdo prévio será
apagado), e 'a' para abrir o arquivo para adição; qualquer escrita será adicionada ao final do arquivo. A opção
'r+' abre o arquivo tanto para leitura como para escrita. O parâmetro mode é opcional, em caso de omissão será
assumido 'r'.
No Windows e no Macintosh, 'b' adicionado a string de modo indica que o arquivo será aberto no formato
binário. Sendo assim, existem os modos compostos : 'rb', 'wb', e 'r+b'. O Windows faz distinção entre
arquivos texto e binários: os caracteres terminadores de linha em arquivos texto são levemente alterados em
leituras e escritas. Essa mudança por-trás-do-pano é útil em arquivos texto ASCII, mas irá corromper um arquivo
binário como no caso de arquivos 'JPEG' ou 'EXE'. Seja muito cuidadoso em usar o modo binário ao manipular
tais arquivos.
7.2.1 Métodos de Objetos de Arquivos
A título de simplificação, o resto dos exemplos nesta seção irá assumir que o objeto de arquivo chamado f já foi
criado.
Para ler o conteúdo de um arquivo chame f.read(size), que lê um punhado de dados retornando-os como
string. O argumento numérico size é opcional. Quando size for omitido ou negativo, todo o conteúdo do arquivo
será lido e retornado. É problema seu se o conteúdo do arquivo é o dobro da memória disponível na máquina.
Caso contrário, no máximo size bytes serão lidos e retornados. Se o fim do arquivo for atingido, f.read() irá
retornar uma string vazia ().
>>> f.read()
'Esse é todo o conteúdo do arquivo.\n'
>>> f.read()
''
f.readline() lê uma única linha do arquivo. O caractere de retorno de linha (\n) é deixado ao final da string,
só sendo omitido na última linha do arquivo se ele já não estiver presente lá. Isso elimina a ambiguidade no
valor de retorno. Se f.readline() retornar uma string vazia, então o arquivo acabou. Linhas em branco são
representadas por '\n': uma string contendo unicamente o terminador de linha.
>>> f.readline()
'Essa é a primeira linha do arquivo.\n'
>>> f.readline()
'Segunda linha do arquivo\n'
>>> f.readline()
''
f.readlines() retorna uma lista contendo todas as linhas do arquivo. Se for fornecido o parâmetro opcional
sizehint, será lida a quantidade especificada de bytes e mais o suficiente para completar uma linha. Frequente-
mente, esta operação é utilizada para ler arquivos muito grandes sem ter que ler todo o arquivo para a memória de
uma só vez. Apenas linhas completas serão retornadas.
>>> f.readlines()
['Essa é a primeira linha do arquivo.\n', 'Segunda linha do arquivo\n']
50
Capítulo 7. Entrada e Saída
Uma maneira alternativa de ler linhas do arquivo é usando um laço diretamente com o objeto arquivo. É mais
eficiente, rápido e resulta em código mais simples:
>>> for line in f:
print line,
Esta é a primeira linha do arquivo.
Segunda linha do arquivo.
Essa alternativa é bem mais simples, mas não oferece tanto controle. Como as duas alternativas são um pouco
diferentes internamente, no gerenciamento de buffers, elas não devem ser misturadas.
f.write(string) escreve o conteúdo da string para o arquivo, retornando None.
>>> f.write('Isso é um teste.\n')
Ao escrever algo que não seja uma string, é necessário convertê-lo antes:
>>> value = ('a resposta', 42)
>>> s = str(value)
>>> f.write(s)
f.tell() retorna um inteiro que indica a posição corrente de leitura ou escrita no arquivo, medida em bytes
desde o início do arquivo. Para mudar a posição utilize 'f.seek(offset, from_what)'. A nova posição é
computada pela soma do offset a um ponto de referência, que por sua vez é definido pelo argumento from_what.
O argumento from_what pode assumir o valor 0 para indicar o início do arquivo, 1 para indicar a posição corrente
e 2 para indicar o fim do arquivo. Este parâmetro pode ser omitido, quando é assumido o valor default 0.
>>>
>>>
>>>
>>>
'5'
>>>
>>>
'd'
f = open('/tmp/workfile', 'r+')
f.write('0123456789abcdef')
f.seek(5)
# Vai para o sexto byte
f.read(1)
f.seek(-3, 2) # Vai para o terceiro byte antes do fim
f.read(1)
Quando acabar de utilizar o arquivo, chame f.close() para fechá-lo e liberar recursos. Qualquer tentativa de
acesso ao arquivo depois dele ter sido fechado implicará em falha.
>>> f.close()
>>> f.read()
Traceback (most recent call last):
File "<stdin>", line 1, in ?
ValueError: I/O operation on closed file
Objetos de arquivo podem ter métodos adicionais, tais como isatty() e truncate() que são usados com
menos frequência, consulte a Library Reference para obter maiores informações.
7.2.2 O Módulo pickle
Strings podem ser facilmente escritas e lidas de um arquivo. Números exigem um pouco mais de esforço, uma
vez que o método read() só trabalha com strings. Portanto, pode ser utilizada a função int(), que recebe uma
string '123' e a converte para o respectivo valor inteiro. Entretanto, quando estruturas de dados mais complexas
(listas, dicionários, instâncias de classe,etc) estão envolvidas, o processo se torna mais complicado.
7.2. Leitura e Escrita de Arquivos
51
Para que não seja necessário que usuários estejam constantemente escrevendo e depurando código que torna
estruturas de dados persistentes, Python oferece o módulo padrão pickle. Este módulo permite que praticamente
qualquer objeto Python (até mesmo código!) seja convertido para uma representação string. Este processo é
denominado pickling. E unpickling é o processo reverso de reconstruir o objeto a partir de sua representação
string. Enquanto estiver representado como uma string, o objeto pode ser armazenado em arquivo, transferido
pela rede, etc.
Se você possui um objeto qualquer x, e um objeto arquivo f que foi aberto para escrita, a maneira mais simples
de utilizar este módulo é:
pickle.dump(x, f)
Para desfazer, se f for agora um objeto de arquivo pronto para leitura:
x = pickle.load(f)
Existem outras variações desse processo úteis quando se precisa aplicar sobre muitos objetos ou o destino da
representação string não é um arquivo. Consulte a documentação para pickle na Referência da Biblioteca
Python para obter informações detalhadas.
Utilizar o módulo pickle é a forma padrão de tornar objetos Python persistentes, permitindo a reutilização dos
mesmos entre diferentes programas, ou pelo mesmo programa em diferentes sessões de utilização. A represen-
tação string dos dados é tecnicamente chamada objeto persistente, como já foi visto. Justamente porque o módulo
pickle é amplamente utilizado, vários autores que escrevem extensões para Python tomam o cuidado de garantir
que novos tipos de dados sejam compatíveis com esse processo.
52
Capítulo 7. Entrada e Saída
CAPÍTULO
EIGHT
Erros e Exceções
Até agora mensagens de erro foram apenas mencionadas, mas se você testou os exemplos, talvez tenha esbarrado
em algumas. Existem pelo menos dois tipos distintos de erros: erros de sintaxe e exceções.
8.1
Erros de Sintaxe
Erros de sintaxe, também conhecidos como erros de parse, são provavelmente os mais frequentes entre aqueles
que ainda estão aprendendo Python:
>>> while True print 'Hello world'
File "<stdin>", line 1, in ?
while True print 'Hello world'
^
SyntaxError: invalid syntax
O parser repete a linha inválida e apresenta uma pequena 'flecha' apontando para o ponto da linha em que o
erro foi encontrado. O erro é detectado pelo token que precede a flecha. No exemplo, o erro foi detectado na
palavra-reservada print, uma vez que o dois-pontos (':') está faltando. Nome de arquivo e número de linha são
impressos para que você possa rastrear o erro no texto do script.
8.2
Exceções
Mesmo que um comando ou expressão estejam sintaticamente corretos, talvez ocorra um erro na hora de sua
execução. Erros detectados durante a execução são chamados exceções e não são necessariamente fatais. Logo
veremos como tratá-las em programas Python. A maioria das exceções não são tratadas e acabam resultando em
mensagens de erro:
>>> 10 * (1/0)
Traceback (most recent call last):
File "<stdin>", line 1, in ?
ZeroDivisionError: integer division or modulo by zero
>>> 4 + spam*3
Traceback (most recent call last):
File "<stdin>", line 1, in ?
NameError: name 'spam' is not defined
>>> '2' + 2
Traceback (most recent call last):
File "<stdin>", line 1, in ?
TypeError: cannot concatenate 'str' and 'int' objects
A última linha da mensagem de erro indica o que aconteceu. Exceções surgem com diferentes tipos, e o tipo
53
é impresso como parte da mensagem . Os tipos no exemplo são: ZeroDivisionError, NameError e
TypeError. A string impressa como sendo o tipo da exceção é o nome interno da exceção que ocorreu. Isso é
verdade para todas exceções pré-definidas em Python, mas não é necessariamente verdade para exceções definidas
pelo usuário.
O resto da linha é um detalhamento que depende do tipo da exceção ocorrida e sua causa.
A parte anterior da mensagem de erro apresenta o contexto onde ocorreu a exceção. Essa informação é denominada
stack traceback (N.d.T: rastreamento da pilha para trás). Em geral, contém uma lista de linhas do código fonte,
sem apresentar, no entanto, valores lidos da entrada padrão.
O documento Referência da Biblioteca Python lista as exceções pré-definidas e seus significados.
8.3
Tratamento de Exceções
É possível escrever programas que tratam exceções específicas. Observe o exemplo seguinte, que pede dados ao
usuário até que um inteiro válido seja fornecido, ainda permitindo que o programa seja interrompido (utilizando
Control-C ou seja lá o que for que o sistema operacional suporte). Note que uma interrupção gerada pelo
usuário será sinalizada pela exceção KeyboardInterrupt.
>>> while True:
...
try:
...
x = int(raw_input("Entre com um número: "))
...
break
...
except ValueError:
...
print "Opa! Esse número não é válido. Tente de novo..."
...
A construção try funciona da seguinte maneira:
• Primeiramente, a cláusula try (o conjunto de comandos entre as palavras-reservadas try e except ) é
executado.
• Se não for gerada exceção, a cláusula except é ignorada e termina a execução da construção try.
• Se uma execução ocorre durante a execução da cláusula try, os comandos remanescentes na cláusula são
ignorados. Se o tipo da exceção ocorrida tiver sido previsto junto àlguma palavra-reservada except, então
essa cláusula será executada. Ao fim da cláusula também termina a execução do try como um todo.
• Se a exceção ocorrida não foi prevista em nenhum tratador except da construção try em que ocorreu,
então ela é entregue a uma construção try mais externa. Se não existir nenhum tratador previsto para tal
exceção (chamada unhandled exception), a execução encerra com uma mensagem de erro.
A construção try pode ter mais de uma cláusula except para especificar múltiplos tratadores para diferentes
exceções. No máximo um único tratador será ativado. Tratadores só são sensíveis as exceções levantadas no
interior da cláusula try, e não que tenha ocorrido no inteiror de outro tratador num mesmo try. Um tratador
pode ser sensível a múltiplas exceções, desde que as especifique em uma tupla:
... except (RuntimeError, TypeError, NameError): ...
pass
A última cláusula except pode omitir o nome da exceção, servindo como uma máscara genérica. Utilize esse
recurso com extrema cautela, uma vez que isso pode esconder errors do programador e do usuário. Também
pode ser utilizado para imprimir uma mensagem de erro, ou re-levantar (re-raise) a exceção de forma que um
“chamador” também possa tratá-la.
54
Capítulo 8. Erros e Exceções
import sys
try:
f = open('myfile.txt')
s = f.readline()
i = int(s.strip())
except IOError, (errno, strerror):
print "I/O error(%s): %s" % (errno, strerror)
except ValueError:
print "Could not convert data to an integer."
except:
print "Unexpected error:", sys.exc_info()[0]
raise
A construção try . . . except possui uma cláusula else opcional, que quando presente, deve ser colocada depois
de todas as outras cláusulas. É útil para um código que precisa ser executado se nenhuma exceção foi levantada.
Por exemplo:
for arg in sys.argv[1:]:
try:
f = open(arg, 'r')
except IOError:
print 'cannot open', arg
else:
print arg, 'has', len(f.readlines()), 'lines'
f.close()
Este recurso é melhor do que simplesmente adicionar o código do else ao corpo da cláusula try, pois mantém
as exceções levantadas no else num escopo diferente de tratamento das exceções levantadas na cláusula try.
Quando uma exceção ocorre, ela pode estar associada a um valor chamado argumento da exceção. A presença e o
tipo do argumento dependem do tipo da exceção.
A cláusula except pode especificar uma variável depois do nome (ou da tupla de nomas) exceção. A variável é
ligada à instância dela com os argumentos armazenados em instance.args. Por conveniência, a instância
define os métodos __getitem__ e __str__ para que os argumentos possam ser acessados sem necessidada
de recorrer a .args.
>>> try:
...
raise Exception('spam', 'eggs')
... except Exception, inst:
...
print type(inst)
# the exception instance
...
print inst.args
# arguments stored in .args
...
print inst
# __str__ allows args to printed directly
...
x, y = inst
# __getitem__ allows args to be unpacked directly
...
print 'x =', x
...
print 'y =', y
...
<type 'instance'>
('spam', 'eggs')
('spam', 'eggs')
x = spam
y = eggs
Se uma exceção possui argumento, ele é impresso ao final do detalhamento de expressões não tratadas (unhandled
exceptions).
Além disso, tratadores de exceção são capazes de capturar exceções que tenham sido levantadas no interior de
funções invocadas na cláusula try. Por exemplo:
8.3. Tratamento de Exceções
55
>>> def this_fails():
...
x = 1/0
...
>>> try:
...
this_fails()
... except ZeroDivisionError, detail:
...
print 'Handling run-time error:', detail
...
Handling run-time error: integer division or modulo by zero
8.4
Levantando Exceções
A palavra-reservada raise permite ao programador forçar a ocorrência de um determinado tipo de exceção. Por
exemplo:
>>> raise NameError, 'HiThere'
Traceback (most recent call last):
File "<stdin>", line 1, in ?
NameError: HiThere
O primeiro argumento de raise é o nome da exceção a ser levantada. O segundo argumento, opcional, é o
argumento da exceção. O código acima pode ser escrito como raise NameError('HiThere). Qualquer
forma funciona bem, mas parece haver uma preferência crescente pela última.
Caso você precise determinar se uma exceção foi levantada ou não, mas não quer manipular o erro, uma forma
simples de raise permite que você levante-a novamente.
>>> try:
...
raise NameError, 'HiThere'
... except NameError:
...
print 'An exception flew by!'
...
raise
...
An exception flew by!
Traceback (most recent call last):
File "<stdin>", line 2, in ?
NameError: HiThere
8.5
Exceções Definidas pelo Usuário
Programas podem definir novos tipos de exceções, através da criação de uma nova classe. Devem ser subclasses
da classe Exception, direta ou indiretamente. Por exemplo:
56
Capítulo 8. Erros e Exceções
>>> class MyError(Exception):
...
def __init__(self, value):
...
self.value = value
...
def __str__(self):
...
return repr(self.value)
...
>>> try:
...
raise MyError(2*2)
... except MyError, e:
...
print 'My exception occurred, value:', e.value
...
My exception occurred, value: 4
>>> raise MyError, 'oops!'
Traceback (most recent call last):
File "<stdin>", line 1, in ?
__main__.MyError: 'oops!'
Neste exemplo, o método __init__ de Exception foi redefinido. O novo comportamento simplesmente cria
o atributo value. Isto substitui o comportamento padrão de criar o atributo args.
Classes para exceções podem ser definidas para fazer qualquer coisa que qualquer outra classe faz, mas em geral
são bem simples, freqüentemente oferecendo apenas alguns atributos que fornecem informações sobre o erro que
ocorreu. Ao criar um módulo que pode gerar diversos erros, uma prática comum é criar uma classe base para as
exceções definidas por aquele módulo, e as classes específicas para cada condição de erro como subclasses dela:
class Error(Exception):
"""Base class for exceptions in this module."""
pass
class InputError(Error):
"""Exception raised for errors in the input.
Attributes:
expression -- input expression in which the error occurred
message -- explanation of the error
"""
def __init__(self, expression, message):
self.expression = expression
self.message = message
class TransitionError(Error):
"""Raised when an operation attempts a state transition that's not
allowed.
Attributes:
previous -- state at beginning of transition
next -- attempted new state
message -- explanation of why the specific transition is not allowed
"""
def __init__(self, previous, next, message):
self.previous = previous
self.next = next
self.message = message
Muitas exceções são definidas com nomes que terminam em “Error,” , de forma semelhante ao estilo usado com
as exceções padrão da linguagem.
Muitos módulos padrão se utilizam disto para reportar erros que ocorrem no interior das funções que definem.
Mais informações sobre esse mecanismo serão descritas no capítulo 9, “Classes.”
8.5. Exceções Definidas pelo Usuário
57
8.6
Definindo Ações de Limpeza
A construção try possui outra cláusula opcional, cuja finalidade é permitir a implementação de ações de limpeza,
que sempre devem ser executadas independentemente da ocorrência de exceções. Como no exemplo:
>>> try:
...
raise KeyboardInterrupt
... finally:
...
print 'Goodbye, world!'
...
Goodbye, world!
Traceback (most recent call last):
File "<stdin>", line 2, ?
KeyboardInterrupt
A cláusula finally é executada sempre, ocorrendo ou não uma exceção. Quando ocorre a exceção, é como se a
exceção fosse sempre levantada após a execução do código na cláusula finally. Mesmo que haja um break ou
return dentro do try, ainda assim o finally será executado.
O código na cláusula finally é útil para liberar recursos externos (como arquivos e conexões de rede), não impor-
tando se o uso deles foi bem sucedido.
A construção try pode ser seguida da cláusula finally ou de um conjunto de cláusulas except, mas nunca
ambas (não ficaria muito claro qual deve ser executada primeiro).
58
Capítulo 8. Erros e Exceções
CAPÍTULO
NINE
Classes
O mecanismo de classes em Python foi adicionado à linguagem de forma a minimizar a sobrecarga sintática e
semântica. É uma mistura de mecanismos equivalentes encontrados em C++ e Modula-3. Assim como é válido
para módulos, classes em Python não impõe barreiras entre o usuário e a definição. Contudo, dependem da “cor-
dialidade” do usuário para não quebrar a definição. Todavia, as características mais importantes de classes foram
asseguradas: o mecanismo de herança permite múltiplas classes base, uma classe derivada pode sobrescrever
quaisquer métodos de uma classe ancestral, e um método pode invocar outro método homônimo de uma classe
ancestral. E mais, objetos podem armazenar uma quantidade arbitrária de dados privados.
Na terminologia de C++, todos os membros de uma classe (incluindo dados) são public, e todos as funções
membro são virtual. Não existem construtores ou destrutores especiais.
Como em Modula-3, não existem atalhos para referenciar membros do objeto de dentro dos seus métodos. Um
método (função de classe) é declarado com um primeiro argumento explícito representando o objeto (instância da
classe) , que é fornecido implicitamente pela invocação.
Como em Smalltalk (e em Java), classes são objetos. Mas em Python, todos os tipos de dados são objetos.
Isso fornece uma semântica para importação e renomeamento. Ao contrário de C++ ou Modula-3, tipos pré-
definidos podem ser utilizados como classes base para extensões de usuário por herança. Como em C++, mas
diferentemente de Modula-3, a maioria dos operadores (aritiméticos, indexação,etc) podem ser redefinidos para
instâncias de classe.
9.1

Uma Palavra Sobre Terminologia


Objetos tem individualidade, e podem estar vinculados a múltiplos nomes (em diferentes escopos). Essa facilidade
é chamada aliasing em outras linguagens. À primeira vista não é muito apreciada, e pode ser seguramente ignorada
ao lidar com tipos imutáveis (números, strings, tuplas). Entretanto, aliasing tem um efeito intencional sobre a
semântica de código em Python envolvendo objetos mutáveis como listas, dicionários, e a maioria das entidades
externas a um programa como arquivos, janelas, etc. Alias (N.d.T: sinônimos) funcionam de certa forma como
ponteiros, em benefício do programamdor. Por exemplo, passagem de objetos como parâmetro é barato, pois só o
ponteiro é passado na implementação. E se uma função modifica um objeto passado como argumento, o chamador
vai ver a mudança – o que elimina a necessidade de um duplo mecanismo de passagem de parâmetros como em
Pascal.
9.2
Escopos e Espaços de Nomes em Python
Antes de introduzir classes, é preciso falar das regras de escopo em Python. Definições de classe empregam
alguns truques com espaços de nomes. Portanto, é preciso entender bem de escopos e espaços de nomes antes.
Esse conhecimento é muito útil para o programador avançado em Python.
Iniciando com algumas definições.
59
Um espaço de nomes é um mapeamento entre nomes e objetos. Presentemente, são implementados como di-
cionários, isso não é perceptível (a não ser pelo desempenho) e pode mudar no futuro. Exemplos de espaços de
nomes são: o conjunto de nomes pré-definidos (funções como abs() e exceções), nomes globais em módulos
e nomes locais em uma função. De uma certa forma, os atributos de um objeto também formam um espaço de
nomes. O que há de importante para saber é que não existe nenhuma relação entre nomes em espaços distintos.
Por exemplo, dois módulos podem definir uma função de nome “maximize” sem confusão – usuários dos módulos
devem prefixar a função com o nome do módulo para evitar colisão.
A propósito, eu utilizo a palavra atributo para qualquer nome depois de um ponto. Na expressão z.real, por
exemplo, real é um atributo do objeto z. Estritamente falando, referências para nomes em módulos são atributos:
na expressão modname.funcname, modname é um objeto módulo e funcname é seu atributo. Neste caso,
existe um mapeamento direto entre os os atributos de um módulo e os nomes globais definidos no módulo: eles
compartilham o mesmo espaço de nomes.

1
Atributos podem ser somente de leitura ou não. Atributos de módulo são passíveis de atribuição, você pode
escrever 'modname.the_answer = 42', e remoção pelo comando del ('del modname.the_answer').


Espaços de nomes são criados em momentos diferentes e possuem diferentes longevidades. O espaço de nomes
que contém os nomes pré-definidos é criado quando o interpretador inicializa e nunca é removido. O espaço de
nomes global é criado quando uma definição de módulo é lida, e normalmente duram até a saída do interpretador.
Os comandos executados pela invocação do interpertador, ou pela leitura de um script, ou interativamente são
parte do módulo chamado __main__, e portanto possuem seu próprio espaço de nomes (os nomes pré-definidos
possuem seu próprio espaço de nomes no módulo chamado __builtin__).


O espaço de nomes local para uma função é criado quando a função é chamada, e removido quando a função
retorna ou levanta uma exceção que não é tratada na própria função. Naturalmente, chamadas recursivas de uma
função possuem seus próprios espaços de nomes.


Um escopo é uma região textual de um programa Python onde um espaço de nomes é diretamente acessível. Onde
“diretamente acessível” significa que uma referência sem qualificador especial permite o acesso ao nome.


Ainda que escopos sejam determinados estaticamente, eles são usados dinamicamente. A qualquer momento
durante a execução, existem no mínimo três escopos diretamente acessíveis: o escopo interno (que é procurado
primeiro) contendo nomes locais, o escopo intermediário (com os nomes globais do módulo) e o escopo externo
(procurado por último) contendo os nomes pré-definidos.
Se um nome é declarado como global, então todas as referências e atribuições de valores vão diretamente para
o escopo intermediário que contém os nomes do módulo. Caso contrário, todas as variáveis encontradas fora do
escopo interno são apenas para leitura (a tentativa de atribuir valores a essas variáveis irá simplesmente criar uma
variável local, no escopo interno, não alterando nada na variável de nome idêntico fora dele).
Normalmente, o escopo local referencia os nomes locais da função corrente. Fora de funções, o escopo local
referencia os nomes do escopo global (espaço de nomes do módulo). Definições de classes adicionam um espaço
de nomes ao escopo local.
É importante perceber que escopos são determinados textualmente. O escopo global de uma função definida em
um módulo é o espaço de nomes deste módulo, sem importar de onde ou de que alias (N.d.T. sinônimo) a função
é invocada. Por outro lado, a efetiva busca de nomes é dinâmica, ocorrendo durante a execução. A evolução da
linguagem está caminhando para uma resolução de nomes estática, em tempo de compilação, que não dependa de
resolução dinâmica de nomes. (de fato, variáveis locais já são resolvidas estaticamente.)
Um detalhe especial é que atribuições são sempre vinculadas ao escopo interno. Atribuições não copiam dados,
simplesmente vinculam objetos a nomes. O mesmo é verdade para remoções. O comando 'del x' remove o
vínculo de x do espaço de nomes referenciado pelo escopo local. De fato, todas operações que introduzem novos
nomes usam o escopo local. Em particular, comandos import e definições de função vinculam o módulo ou a
função ao escopo local (a palavra-reservada global pode ser usada para indicar que certas variáveis residem no
escopo global ao invés do local).
1 Exceto por uma coisa. Objetos Módulo possuem um atributo de leitura escondido chamado __dict__ que retorna o dicionário utilizado
para implementar o espaço de nomes do módulo. O nome __dict__ é um atributo, porém não é um nome global. Obviamente, utilizar isto
violaria a abstração de espaço de nomes, portanto seu uso deve ser restrito. Um exemplo válido é o caso de depuradores post-mortem.
60
Capítulo 9. Classes
9.3
Primeiro Contato com Classes
Classes introduzem novidades sintáticas, três novos tipos de objetos, e também semântica nova.
9.3.1 Sintaxe de Definição de Classe
A forma mais simples de definir uma classe é:
class NomeDaClasse:
<comando-1>
.
.
.
<comando-N>
Definições de classes, como definições de funções (comandos def) devem ser executados antes que tenham
qualquer efeito. Você pode colocar uma definição de classe após um teste condicional if ou dentro de uma
função.

Na prática, os comandos dentro de uma classe serão definições de funções, mas existem outros comandos que
são permitidos. Definições de função dentro da classe possuem um lista peculiar de argumentos determinada pela
convenção de chamada a métodos.

Quando se fornece uma definição de classe, um novo espaço de nomes é criado. Todas atribuições de variáveis
são vinculadas a este escopo local. Em particular, definições de função também são armazenadas neste escopo.


Quando termina o processamento de uma definição de classe (normalmente, sem erros), um objeto de classe é
criado. Este objeto encapsula o conteúdo do espaço de nomes criado pela definição da classe. O escopo local ativo
antes da definição da classe é restaurado, e o objeto classe é vinculado a este escopo com o nome dado a classe.


9.3.2 Objetos de Classe
Objetos de Classe suportam dois tipos de operações: referências a atributos e instanciação.
Referências a atributos de classe utilizam a sintaxe padrão utilizada para quaisquer referências a atributos em
Python: obj.name. Atributos válidos são todos os nomes presentes no espaço de nomes da classe quando o
objeto classe foi criado. Portanto, se a definição da classe era:
class MyClass:
"Um exemplo simples de classe"
i = 12345
def f(self):
return 'hello world'
então MyClass.i e MyClass.f são referências a atributos válidos, retornando um inteiro e um objeto função,
respectivamente. Atributos de classe podem receber atribuições, logo você pode mudar o valor de MyClass.i
por atribuição. __doc__ é também um atributo válido, que retorna a docstring pertencente a classe: "Um
exemplo simples de classe".
Instanciação de Classe também utiliza uma notação de função. Apenas finja que o objeto classe não possui
parâmetros e retorna uma nova instância da classe. Por exemplo:
x = MyClass()
cria uma nova instância da classe e atribui o objeto resultante a variável local x.
A operação de instanciação (“calling” um objeto de classe) cria um objeto vazio. Muitas classes preferem criar um
novo objeto em um estado inicial pré-determinado. Para tanto, existe um método especial que pode ser definido
9.3. Primeiro Contato com Classes
61
pela classe, __init__(), veja:
def __init__(self):
self.data = []
Quando uma classe define um método __init__(), o processo de instânciação automáticamente invoca __-
init__() sobre a recém-criada instância de classe. Neste exemplo, uma nova intância já inicializada pode ser
obtida por:
x = MyClass()
Naturalmente, o método __init__() pode ter argumentos para aumentar sua flexibilidade. Neste caso, os
argumentos passados para a instanciação de classe serão delegados para o método __init__(). Como ilustrado
em:
>>> class Complex:
...
def __init__(self, realpart, imagpart):
...
self.r = realpart
...
self.i = imagpart
...
>>> x = Complex(3.0, -4.5)
>>> x.r, x.i
(3.0, -4.5)
9.3.3 Instâncias
Agora, o que podemos fazer com instâncias ? As únicas operações reconhecidas por instâncias são referências a
atributos. Existem dois tipos de nomes de atributos válidos: atributos de dados e métodos.
Atributos-de-dados, que correspondem a “variáveis de instância” em Smalltalk, e a “membros” em C++.
Atributos-de-dados não não precisam ser declarados. Assim como variáveis locais, eles passam a existir na
primeira vez em que é feita uma atribuição. Por exemplo, se x é uma instância de MyClass criada acima, o
próximo trecho de código irá imprimir o valor 16, sem deixar rastro (por causa do del):
x.counter = 1
while x.counter < 10:
x.counter = x.counter * 2
print x.counter
del x.counter
O outro tipo de referências a atributos são métodos. Um método é uma função que “pertence a” uma instância (em
Python, o termo método não é aplicado exclusivamente a instâncias de classes definidas pelo usuário: outros tipos
de objetos também podem ter métodos; por exemplo, objetos listas possuem os métodos: append, insert, remove,
sort, etc).
Nomes de métodos válidos de uma instância dependem de sua classe. Por definição, todos atributos de uma
classe que são funções equivalem a um método presente nas instâncias. No nosso exemplo, x.f é uma referência
de método válida já que MyClass.f é uma função, enquanto x.i não é, já que MyClass.i não é função.
Entretanto, x.f não é o mesmo que MyClass.f — o primeiro é um método de objeto , o segundo é um objeto
função.
9.3.4 Métodos de Objeto
Normalmente, um método é chamado imediatamente:
62
Capítulo 9. Classes
x.f()
No exemplo com MyClass o resultado será a string 'hello world'. No entanto, não é obrigatótio chamar
o método imediatamente: como x.f é também um objeto (tipo método), ele pode ser armazenado e invocado a
posteriori. Por exemplo:
xf = x.f
while True:
print xf()
continuará imprimindo 'hello world' até o final dos tempos.
O que ocorre precisamente quando um método é chamado ? Você deve ter notado que x.f() foi chamado
sem nenhum parâmetro, porém a definição da função f especificava um argumento. O que aconteceu com o
argumento ? Certamente Python levantaria uma exceção se o argumento estivesse faltando...
Talvez você já tenha advinhado a resposta: o que há de especial em métodos é que o objeto (a qual o método
pertence) é passado como o primeiro argumento da função. No nosso exemplo, a chamada x.f() é exatamente
equivalente a MyClass.f(x). Em geral, chamar um método com uma lista de n argumentos é equivalente a
chamar a função na classe correspondente passando a instância como o primeiro argumento antes dos demais
argumentos.
Se você ainda não entendeu como métodos funcionam, talvez uma olhadela na implementação sirva para clarear as
coisas. Quando um atributo de instância é referenciado e não é um atributo de dado, a sua classe é procurada. Se o
nome indica um atributo de classe válido que seja um objeto função, um objeto método é criado pela composição
da instância alvo e do objeto função. Quando o método é chamado com uma lista de argumentos, ele é desempa-
cotado, uma nova lista de argumentos é criada a partir da instância original e da lista original de argumentos do
método. Finalmente, a função é chamada com a nova lista de argumentos.
9.4
Observações Aleatórias
Atributos de dados sobrescrevem atributos métodos homônimos. Para evitar conflitos de nome acindentais, que
podem gerar bugs de difícil rastreio em programas extensos, é sábio utilizar algum tipo de convenção que minimize
a chance de conflitos. Algumas idéias incluem colocar nomes de métodos com inicial maiúscula, prefixar atributos
de dados com uma string única (quem sabe “_”), ou simplesmente utilizar substantivos para atributos e verbos para
métodos.
Atributos de dados podem ser referenciados por métodos da própria instância, bem como por qualquer outro
usuário do objeto. Em outras palavras, classes não servem para implementar tipos puramente abstratos de dados.
De fato, nada em Python torna possível assegurar o encapsulamento de dados. Tudo é convenção. Por outro lado,
a implementação Python, escrita em C, pode esconder completamente detalhes de um objeto ou regular seu acesso
se necessário. Isto pode ser utilizado por extensões a Python escritas em C.
Clientes devem utilizar atributos de dados com cuidado, pois podem bagunçar invariantes mantidos pelos métodos
ao esbarrar nos seus atributos. Portanto, clientes podem adicionar à vontade atributos de dados para uma instância
sem afetar a validade dos métodos, desde que seja evitado o conflito de nomes. Novamente, uma convenção de
nomenclatura poupa muita dor de cabeça.


Não existe atalho para referenciar atributos de dados (ou métodos) de dentro de um método. Isso na verdade
aumenta a legibilidade dos métodos: não há como confundir uma variável local com uma instância global ao dar
uma olhadela em um método desconhecido.


Frequentemente, o primeiro argumento de qualquer método é chamado self. Isso não é nada mais do que
uma convenção, self não possui nenhum significado especial em Python (observe que ao seguir a convenção
seu código se torna legível por uma grande comunidade de desenvolvedores Python e potencialmente poderá se
beneficiar de ferramentas feitas por outrém que se baseie na convenção).


Qualquer função que é também atributo de classe, define um método nas instâncias desta classe. Não é necessário
9.4. Observações Aleatórias
63
que a definição da função esteja textualmente embutida na definição da classe. Atribuir um objeto função a uma
variável local da classe é válido. Por exemplo:
# Função definida fora da classe
def f1(self, x, y):
return min(x, x+y)
class C:
f = f1
def g(self):
return 'hello world'
h = g
Agora f, g e h são todos atributos da classe C que referenciam funções, e consequentemente são todos métodos
de instâncias da classe C, onde h é equivalente a g. No entanto, essa prática pode confundir o leitor do programa.
Métodos podem chamar outros métodos utilizando o argumento self :
class Bag:
def __init__(self):
self.data = []
def add(self, x):
self.data.append(x)
def addtwice(self, x):
self.add(x)
self.add(x)
Métodos podem referenciar nomes globais da mesma forma que funções ordinárias. O escopo global associado a
um método é o módulo contendo sua definição de classe (a classe propriamente dita nunca é usada como escopo
global!). Ainda que seja raro encontrar a necessidade de utilizar dados globais em um método, há diversos usos
legítimos do escopo global. Por exemplo, funções e módulos importados no escopo global podem ser usados por
métodos, bem como as funções e classes definidas no próprio escopo global. Provavelmente, a classe contendo o
método em questão também foi definida neste escopo global. Na próxima seção veremos um conjunto de razões
pelas quais um método desejaria referenciar sua própria classe.
9.5
Herança
Obviamente, uma característica de linguagem não seria digna do nome “classe” se não suportasse herança. A
sintaxe para uma classe derivada se parece com:
class DerivedClassName(BaseClassName):
<statement-1>
.
.
.
<statement-N>
O nome BaseClassName deve estar definido em um escopo contendo a definição da classe derivada. No lugar
do nome da classe base, também são aceitas outras expressões. Isso é muito útil, por exemplo, quando a classe
base é definida em outro módulo:
class DerivedClassName(modname.BaseClassName):
Execução de uma definição de classe derivada procede da mesma forma que a de uma classe base. Quando o objeto
64
Capítulo 9. Classes
classe é construído, a classe base é lembrada. Isso é utilizado para resolver referências a atributos. Se um atributo
requisitado não for encontrado na classe, ele é procurado na classe base. Essa regra é aplicada recursivamente se
a classe base por sua vez for derivada de outra.
Não existe nada de especial sobre instanciação de classes derivadas. DerivedClassName() cria uma nova
instância da classe. Referências a métodos são resolvidas da seguinte forma: o atributo correspondente é procurado
através da cadeia de derivação, e referências a métodos são válidas desde que produzam um objeto do tipo função.
Classes derivadas podem sobrescrever métodos das suas classes base. Uma vez que métodos não possuem priv-
ilégios especiais quando invocam outros métodos no mesmo objeto, um método na classe base que invocava um
outro método da mesma classe base, pode efetivamente acabar invocando um método sobreposto por uma classe
derivada. Para programadores C++ isso significa que todos os métodos em Python são efetivamente virtual.
Um método que sobrescreva outro em uma classe derivada pode desejar na verdade estender, ao invés de substituir,
o método sobrescrito de mesmo nome na classe base. A maneira mais simples de implementar esse comportamento
é chamar diretamente a classe base 'BaseClassName.methodname(self, arguments)'. O que pode
ser útil para os usuários da classe também. Note que isso só funciona se a classe base for definida ou importada
diretamente no escopo global.
9.5.1 Herança Múltipla
Python também suporta uma forma limitada de herança múltipla. Uma definição de classe que herda de várias
classes base é:
class DerivedClassName(Base1, Base2, Base3):
<statement-1>
.
.
.
<statement-N>
A única regra que precisa ser explicada é a semântica de resolução para as referências a atributos de classe.
É feita uma busca em profundidade da esquerda para a direita. Logo, se um atributo não é encontrado em
DerivedClassName, ele é procurado em Base1, e recursivamente nas classes bases de Base1, e apenas
se não for encontrado lá a busca prosseguirá em Base2, e assim sucessivamente.
Para algumas pessoas a busca em largura – procurar antes em Base2 e Base3 do que nos ancestrais de Base1
— parece mais natural. Entretanto, seria preciso conhecer toda a hierarquia de Base1 para evitar um conflito
com um atributo de Base2. Enquanto a busca em profundidade não diferencia o acesso a atributos diretos ou
herdados de Base1.
É sabido que o uso indiscriminado de herança múltipla é o pesadelo da manutenção, sobretudo pela confiança de
Python na adoção de uma convenção de nomenclatura para evitar conflitos. Um problema bem conhecido com
herança múltipla é quando há uma classe derivada de outras que por sua vez possuem um ancestral em comum.
Ainda que seja perfeitamente claro o que acontecerá (a instância possuirá uma única cópia dos atributos de dados
do ancestral comum), não está claro se a semântica é útil.
9.6
Variáveis Privadas
Existe um suporte limitado a identificadores privados em classes. Qualquer identificador no formato __spam (no
mínimo dois caracteres '_' no prefixo e no máximo u m como sufixo) é substituído por _classname__spam,
onde classname é o nome da classe corrente. Essa construção independe da posição sintática do identificador, e
pode ser usada para tornar privadas: instâncias, variáveis de classe e métodos. Pode haver truncamento se o nome
combinado extrapolar 255 caracteres. Fora de classes, ou quando o nome da classe só tem '_', não se aplica esta
construção.
Este procedimento visa oferecer a classes uma maneira fácil de definir variáveis de instância e métodos “privados”,
sem ter que se preocupar com outras variáveis de instância definidas em classes derivadas ou definidas fora da
9.6. Variáveis Privadas
65
classe. Apesar da regra de nomenclatura ter sido projetada para evitar “acidentes”, ainda é possível o acesso e a
manipulação de entidades privadas. O que é útil em determinadas circunstâncias, como no caso de depuradores,
talvez a única razão pela qual essa característica ainda não tenha sido suprimida (detalhe: derivar uma classe com
o mesmo nome da classe base torna possível o uso de seus membros privados! Isso pode ser corrigido em versões
futuras).
Observe que código passado para exec, eval() ou evalfile() não considera o nome da classe que o
invocou como sendo a classe corrente. O modificador global funciona de maneira semelhante, quando se está
restrito ao código que foi byte-compilado em conjunto. A mesma restrição se aplica aos comandos getattr(),
setattr() e delattr(), e a manipulação direta do dicionário __dict__.
9.7
Particularidades
Às vezes, é útil ter um tipo semelhante ao “record” de Pascal ou ao “struct” de C. Uma definição de classe vazia
atende esse propósito:
class Employee:
pass
john = Employee() # Cria um registro vazio de Empregado
# Preenche os campos do registro
john.name = 'John Doe'
john.dept = 'computer lab'
john.salary = 1000
Um trecho de código Python que espera um tipo abstrato de dado em particular, pode receber ao invés do tipo
abstrato uma classe (que emula os métodos que aquele tipo suporta). Por exemplo, se você tem uma função que
formata dados em um objeto arquivo, você pode definir uma classe com os métodos read() e readline()
que utiliza um buffer ao invés do arquivo propriamente dito.
Métodos de instância são objetos, e podem possuir atributos também: m.im_self é o objeto ao qual o método
está ligado, e m.im_func é o objeto função correspondente ao método.
9.7.1 Exceções Também São Classes
Exceções definidas pelo usuário são identificadas por classes. Através deste mecanismo é possível criar hierarquias
extensíveis de exceções.
Existem duas novas semânticas válidas para o comando raise:
raise Class, instance
raise instance
Na primeira forma, instance deve ser uma instância de Class ou de uma classe derivada dela. A segunda
forma é um atalho para:
raise instance.__class__, instance
Uma classe em uma cláusula de exceção é compatível com a exceção se é a mesma classe prevista na cláusula
ou ancestral dela (não o contrário, se na cláusula estiver uma classe derivada não haverá casamento com exceções
base levantadas). No exemplo a seguir será impresso B, C, D nessa ordem:
66
Capítulo 9. Classes
class B:
pass
class C(B):
pass
class D(C):
pass
for c in [B, C, D]:
try:
raise c()
except D:
print "D"
except C:
print "C"
except B:
print "B"
Se a ordem das cláusulas fosse invertida (B no início), seria impresso B, B, B – sempre a primeira cláusula válida
é ativada.
Quando uma mensagem de erro é impressa para uma exceção não tratada, o nome da classe da exceção é impresso,
e depois a instância da exceção é convertida para string pela função str() e é também impressa (após um espaço
e uma vírgula).
9.8
Iteradores
Você já deve ter notado que pode usar laços com a maioria das contêineres usando um comando for:
for element in [1, 2, 3]:
print element
for element in (1, 2, 3):
print element
for key in {'one':1, 'two':2}:
print key
for char in "123":
print char
for line in open("myfile.txt"):
print line
Este estilo de acesso é limpo, conciso e muito conveniente. O uso de iteradores promove uma unificação ao longo
de toda a linguagem. Por trás dos bastidores, o comando for chama iter() no contêiner. Essa função retorna
um iterador que define o método next(), que acessa os elementos da sequência um por vez. Quando acabam os
elementos, nex() levanta a exceção StopIteration, indicando que o laço for deve encerrar. Este exemplo
mostra como tudo funciona:
9.8. Iteradores
67
>>> s = 'abc'
>>> it = iter(s)
>>> it
<iterator object at 0x00A1DB50>
>>> it.next()
'a'
>>> it.next()
'b'
>>> it.next()
'c'
>>> it.next()
Traceback (most recent call last):
File "<stdin>", line 1, in ?
it.next()
StopIteration
Vendo o mecanismo por trás do protocolo usado pelos iteradores, torna-se fácil adicionar esse comportamento às
suas classes. Defina uma método __iter__() que retorna um objeto com um método next(). Se a classe
definir next(), então __iter__() pode simplesmente retornar self:
class Reverse:
"Iterator for looping over a sequence backwards"
def __init__(self, data):
self.data = data
self.index = len(data)
def __iter__(self):
return self
def next(self):
if self.index == 0:
raise StopIteration
self.index = self.index - 1
return self.data[self.index]
>>> for char in Reverse('spam'):
...
print char
...
m
a
p
s
9.9
Geradores
Geradores são uma maneira fácil e poderosa de criar iteradores. Eles são escritos como uma função normal,
mas usam o comando yield() quando desejam retornar dados. Cada vez que next() é chamado, o gerador
continua a partir de onde parou (sempre mantendo na memória os valores e o último comando executado). Um
exemplo mostra como geradores podem ser muito fáceis de criar:
68
Capítulo 9. Classes
def reverse(data):
for index in range(len(data)-1, -1, -1):
yield data[index]
>>> for char in reverse('golf'):
...
print char
...
f
l
o
g
Qualquer coisa feita com geradores também pode ser feita com iteradores baseados numa classe, como descrito
na seção anterior. O que torna geradores tão compactos é que os métodos __iter__() e next() são criados
automaticamente.
Outro ponto chave é que as variáveis locais e o estado da execucação são memorizados automaticamente entre as
chamadas. Isto torna a função mais fácil de escrever e muito mais clara do que uma abordagem usando variáveis
como self.index and self.data.
Além disso, quando geradores terminam, eles levantam StopIteration automaticamente. Combinados, todos
estes aspectos tornam a criação de iteradores tão fácil quanto a de uma função normal.
9.10
Expressões Geradoras
Alguns geradores simples podem ser escritos sucintamente como expressões usando uma sintaxe similar a de
abrangência de listas, mas com parênteses ao invés de colchetes. Essas expressões são destinadas a situações em
que o gerador é usado imediatamente por uma função. Expressões geradoras tendem a ser mais compactas, porém
menos versáteis do que uma definição completa de um gerador, e tendem a ser muito mais amigáveis no consumo
de memória do que uma abrangência de lista equivalente.
Exemplos:
>>> sum(i*i for i in range(10))
285
>>> xvec = [10, 20, 30]
>>> yvec = [7, 5, 3]
>>> sum(x*y for x,y in zip(xvec, yvec))
260
# sum of squares
# dot product
>>> from math import pi, sin
>>> sine_table = dict((x, sin(x*pi/180)) for x in range(0, 91))
>>> unique_words = set(word
for line in page
for word in line.split())
>>> valedictorian = max((student.gpa, student.name) for student in graduates)
>>> data = 'golf'
>>> list(data[i] for i in range(len(data)-1,-1,-1))
['f', 'l', 'o', 'g']
9.10. Expressões Geradoras
69
70
CAPÍTULO
TEN
Um Breve Passeio Pela Biblioteca
Padrão
10.1
Interface Com o Sistema Operacional
O módulo os fornece dúzias de fúnções para interagir com o sistema operacional:
>>> import os
>>> os.system('time 0:02')
0
>>> os.getcwd()
# Retorna o diretório de trabalho atual
'C:\\Python24'
>>> os.chdir('/server/accesslogs')
Tome cuidado para usar a forma 'import os' ao invés de 'from os import *'.
os.open() oculte a função open() que opera de forma muito diferente.
Isto evitará que
As funções internas dir() e help() são úteis como um sistema de ajuda interativa pra lidar com módulos
grandes como os:
>>> import os
>>> dir(os)
<returns a list of all module functions>
>>> help(os)
<returns an extensive manual page created from the module's docstrings>
Para tarefas de gerenciamento diário de arquivos e diretórios, o módulo shutil fornece uma interface de alto
nível bem que é mais simples de usar:
>>> import shutil
>>> shutil.copyfile('data.db', 'archive.db')
>>> shutil.move('/build/executables', 'installdir')
10.2
Caracteres Coringa
O módulo glob fornece uma função para criar listas de arquivos a partir de buscas em diretórios usando caracteres
coringa:
71
>>> import glob
>>> glob.glob('*.py')
['primes.py', 'random.py', 'quote.py']
10.3
Argumentos da Linha de Comando
Scripts geralmente precisam processar argumentos passados na linha de comando. Esses argumentos são ar-
mazenados como uma lista no atributo argv do módulo sys. Por exemplo, teríamos a seguinte saída executando
'python demo.py um dois tres' na linha de comando:
>>> import sys
>>> print sys.argv
['demo.py', 'um', 'dois', 'tres']
O módulo getopt processa os argumentos passados em sys.argv usando as convenções da função U NIX
getopt(). Outros recursos de processamento mais poderosos e flexíveis estão disponíveis no módulo
optparse.
10.4
Redirecionamento de Erros e Encerramento do Programa
O módulo sys também possui atributos para stdin, stdout, e stderr (entrada e saída de dados padrão, saída de
erros, respectivamente). O último é usado para emitir avisos e mensagens de erro visíveis mesmo quando stdout
foi redirecionado:
>>> sys.stderr.write('Warning, log file not found starting a new one\n')
Warning, log file not found starting a new one
A forma mais direta de encerrar um script é usando 'sys.exit()'.
10.5
Reconhecimento de Padrões em Strings
O módulo re fornece ferramentas para lidar processamento de strings através de expressões regulares. Para
reconhecimento de padrões complexos e manipulações elaboradas, expressões regulares oferecem uma solução
sucinta e eficiente:
>>> import re
>>> re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')
['foot', 'fell', 'fastest']
>>> re.sub(r'(\b[a-z]+) \1', r'\1', 'cat in the the hat')
'cat in the hat'
Quando as exigências são simples, métodos de strings são preferíveis por serem mais fáceis de ler e depurar:
>>> 'tea for too'.replace('too', 'two')
'tea for two'
72
Capítulo 10. Um Breve Passeio Pela Biblioteca Padrão
10.6
Matemática
O módulo math oferece acesso às funções da biblioteca C para matemática e ponto flutuante:
>>> import math
>>> math.cos(math.pi / 4.0)
0.70710678118654757
>>> math.log(1024, 2)
10.0
O módulo random fornece ferramentas para gerar seleções aleatórias:
>>> import random
>>> random.choice(['apple', 'pear', 'banana'])
'apple'
>>> random.sample(xrange(100), 10)
# sampling without replacement
[30, 83, 16, 4, 8, 81, 41, 50, 18, 33]
>>> random.random()
# random float
0.17970987693706186
>>> random.randrange(6)
# random integer chosen from range(6)
4
10.7
Acesso à Internet
Há diversos módulos para acesso e processamento de protocolos da internet. Dois dos mais simples são urllib2
para efetuar download de dados a partir de urls e smtplib para enviar mensagens de correio eletrônico:
>>> import urllib2
>>> for line in urllib2.urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl'):
...
if 'EST' in line:
# look for Eastern Standard Time
...
print line
<BR>Nov. 25, 09:43:32 PM EST
>>> import smtplib
>>> server = smtplib.SMTP('localhost')
>>> server.sendmail('soothsayer@example.org', 'jcaesar@example.org',
"""To: jcaesar@example.org
From: soothsayer@example.org
Beware the Ides of March.
""")
>>> server.quit()
10.8
Data e Hora
O módulo datetime fornece classes para manipulação de datas e horas nas mais variadas formas. Apesar da
disponibilidade de aritmética com data e hora, o foco da implementação é na extração eficiente dos membros para
formatação e manipulação. O módulo também oferece objetos que levam os fusos horários em consideração.
10.6. Matemática
73
# dates are easily constructed and formatted
>>> from datetime import date
>>> now = date.today()
>>> now
datetime.date(2003, 12, 2)
>>> now.strftime("%m-%d-%y. %d %b %Y is a %A on the %d day of %B.")
'12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'
# dates support calendar arithmetic
>>> birthday = date(1964, 7, 31)
>>> age = now - birthday
>>> age.days
14368
10.9
Compressão de Dados
Formatos comuns de arquivamento e compressão de dados estão disponíveis diretamente através de alguns módu-
los, entre eles: zlib, gzip, bz2, zipfile e tarfile.
>>> import zlib
>>> s = 'witch which has which witches wrist watch'
>>> len(s)
41
>>> t = zlib.compress(s)
>>> len(t)
37
>>> zlib.decompress(t)
'witch which has which witches wrist watch'
>>> zlib.crc32(s)
226805979
10.10
Medição de Desempenho
Alguns usuários de Python desenvolvem um interesse profundo pelo desempenho relativo de diferentes abordagens
para o mesmo problema. Python oferece uma ferramenta de medição que esclarecem essas dúvidas rapidamente.
Por exemplo, pode ser tentador usar empacotamento e desempacotamento de tuplas ao invés da abordagem tradi-
cional de permutar os argumentos. O módulo timeit rapidamente mostra uma modesta vantagem de desem-
penho:
>>> from timeit import Timer
>>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()
0.57535828626024577
>>> Timer('a,b = b,a', 'a=1; b=2').timeit()
0.54962537085770791
Em contraste com o alto nível de granularidade oferecido pelo módulo timeit, os módulos profile e pstats
disponibilizam ferramentas para identificar os trechos mais críticas em grandes blocos de código.
74
Capítulo 10. Um Breve Passeio Pela Biblioteca Padrão
10.11
Controle de Qualidade
Uma das abordagens usadas no desenvolvimento de software de alta qualidade é escrever testes para cada função
à medida que é desenvolvida e executar esses testes frequentemente durante o processo de desenvolvimento.
O módulo doctest oferece uma ferramenta para realizar um trabalho de varredura e validação de testes es-
critos nas strings de documentação (docstrings) de um programa. A construção dos testes é tão simples quanto
copiar uma chamada típica juntamente dos seus resultados e colá-los na docstring. Isto aprimora a documentação,
fornecendo ao usuário um exemplo real, e permite que o módulo doctest verifique que o código continua fiel à
documentação.
def average(values):
"""Computes the arithmetic mean of a list of numbers.
>>> print average([20, 30, 70])
40.0
"""
return sum(values, 0.0) / len(values)
import doctest
doctest.testmod()
# automatically validate the embedded tests
O módulo unittest não é tão simples de usar quanto o módulo doctest, mas permite que um conjunto muito
maior de testes seja mantido em um arquivo separado:
import unittest
class TestStatisticalFunctions(unittest.TestCase):
def test_average(self):
self.assertEqual(average([20, 30, 70]), 40.0)
self.assertEqual(round(average([1, 5, 7]), 1), 4.3)
self.assertRaises(ZeroDivisionError, average, [])
self.assertRaises(TypeError, average, 20, 30, 70)
unittest.main() # Calling from the command line invokes all tests
10.12
Baterias Incluídas
Python tem uma filosofia de “baterias incluídas”. Isto fica mais evidente através da sofisticação e robustez dos
seus maiores pacotes. Por exemplo:
• Os módulos xmlrpclib e SimpleXMLRPCServer tornam a implementação de chamadas remotas (re-
mote procedure calls) uma tarefa quase trivial. Apesar dos nomes dos módulos, nenhum conhecimento ou
manipulação de XML é necessário.
• O pacote email é uma biblioteca para gerenciamento de mensagens de correio eletrônico, incluindo MIME
e outros baseados no RFC 2822. Diferentemente dos módulos smtplib e poplib que apenas enviam e
recebem mensagens, o pacote email tem um conjunto completo de ferramentas para construir ou decodificar
estruturas complexas de mensagens (incluindo anexos) e para implementação de protocolos de codificação
e cabeçalhos.
• Os pacotes xml.dom e xml.sax oferecem uma implementação robusta deste popular formato de troca de
dados. De maneira semelhante, o módulo csv permite ler e escrever diretamente num formato comum de
bancos de dados. Juntos, estes módulos e pacotes simplificam muito a troca de dados entre aplicações em
Python e outras ferramentas.
10.11. Controle de Qualidade
75
• Internacionalização é disponível através de diversos módulos, como gettext, locale, e o pacote
codecs.
76
Capítulo 10. Um Breve Passeio Pela Biblioteca Padrão
CAPÍTULO
ELEVEN
Um Breve Passeio Pela Biblioteca
Padrão – Parte II
Este segundo passeio cobre alguns módulos mais avançados que cobrem algumas necessidades de programação
profissional. Estes módulos raramente aparecem em scripts pequenos.
11.1
Formatando Saída
O módulo repr oferece uma versão da função repr() customizada para abreviar a exibição contêineres grandes
ou aninhados muito profundamente:
>>> import repr
>>> repr.repr(set('supercalifragilisticexpialidocious'))
"set(['a', 'c', 'd', 'e', 'f', 'g', ...])"
O módulo pprint oferece controle mais sofisticada na exibição de tanto objetos internos quanto aqueles
definidos pelo usuário de uma maneira legível através do interpretador. Quando o resultado é maior do que uma
linha, o “pretty printer” acrescenta quebras de linha e indentação para revelar as estruturas de dados de maneira
mais clara:
>>> import pprint
>>> t = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta',
...
'yellow'], 'blue']]]
...
>>> pprint.pprint(t, width=30)
[[[['black', 'cyan'],
'white',
['green', 'red']],
[['magenta', 'yellow'],
'blue']]]
O módulo textwrap formata parágrafos de texto de forma que caibam em uma dada largura de tela:
77
>>> import textwrap
>>> doc = """The wrap() method is just like fill() except that it returns
... a list of strings instead of one big string with newlines to separate
... the wrapped lines."""
...
>>> print textwrap.fill(doc, width=40)
The wrap() method is just like fill()
except that it returns a list of strings
instead of one big string with newlines
to separate the wrapped lines.
O módulo locale acessa um banco de dados de formatos de dados específicos à determinada cultura. O atributo
grouping da função format, oferece uma forma simples de formatar números com separadores:
>>> import locale
>>> locale.setlocale(locale.LC_ALL, 'English_United States.1252')
'English_United States.1252'
>>> conv = locale.localeconv()
# get a mapping of conventions
>>> x = 1234567.8
>>> locale.format("%d", x, grouping=True)
'1,234,567'
>>> locale.format("%s%.*f", (conv['currency_symbol'],
...
conv['frac_digits'], x), grouping=True)
'\$1,234,567.80'
11.2
Templating
The string module includes a versatile Template class with a simplified syntax suitable for editing by end-
users. This allows users to customize their applications without having to alter the application.
The format uses placeholder names formed by '$' with valid Python identifiers (alphanumeric characters and
underscores). Surrounding the placeholder with braces allows it to be followed by more alphanumeric letters with
no intervening spaces. Writing '$$' creates a single escaped '$':
>>> from string import Template
>>> t = Template('\${village}folk send \$\$10 to \$cause.')
>>> t.substitute(village='Nottingham', cause='the ditch fund')
'Nottinghamfolk send \$10 to the ditch fund.'
The substitute method raises a KeyError when a placeholder is not supplied in a dictionary or a keyword
argument. For mail-merge style applications, user supplied data may be incomplete and the safe_substitute
method may be more appropriate — it will leave placeholders unchanged if data is missing:
>>> t = Template('Return the \$item to \$owner.')
>>> d = dict(item='unladen swallow')
>>> t.substitute(d)
Traceback (most recent call last):
. . .
KeyError: 'owner'
>>> t.safe_substitute(d)
'Return the unladen swallow to \$owner.\$'
Template subclasses can specify a custom delimiter. For example, a batch renaming utility for a photo browser
78
Capítulo 11. Um Breve Passeio Pela Biblioteca Padrão – Parte II
may elect to use percent signs for placeholders such as the current date, image sequence number, or file format:
>>> import time, os.path
>>> photofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']
>>> class BatchRename(Template):
...
delimiter = '%'
>>> fmt = raw_input('Enter rename style (%d-date %n-seqnum %f-format):
Enter rename style (%d-date %n-seqnum %f-format): Ashley_%n%f
')
>>> t = BatchRename(fmt)
>>> date = time.strftime('%d%b%y')
>>> for i, filename in enumerate(photofiles):
...
base, ext = os.path.splitext(filename)
...
newname = t.substitute(d=date, n=i, f=ext)
...
print '%s --> %s' % (filename, newname)
img_1074.jpg --> Ashley_0.jpg
img_1076.jpg --> Ashley_1.jpg
img_1077.jpg --> Ashley_2.jpg
Another application for templating is separating program logic from the details of multiple output formats. This
makes it possible to substitute custom templates for XML files, plain text reports, and HTML web reports.
11.3
Working with Binary Data Record Layouts
The struct module provides pack() and unpack() functions for working with variable length binary record
formats. The following example shows how to loop through header information in a ZIP file (with pack codes
"H" and "L" representing two and four byte unsigned numbers respectively):
import struct
data = open('myfile.zip', 'rb').read()
start = 0
for i in range(3):
# show the first 3 file headers
start += 14
fields = struct.unpack('LLLHH', data[start:start+16])
crc32, comp_size, uncomp_size, filenamesize, extra_size = fields
start += 16
filename = data[start:start+filenamesize]
start += filenamesize
extra = data[start:start+extra_size]
print filename, hex(crc32), comp_size, uncomp_size
start += extra_size + comp_size
11.4
# skip to the next header
Multi-threading
Threading is a technique for decoupling tasks which are not sequentially dependent. Threads can be used to
improve the responsiveness of applications that accept user input while other tasks run in the background. A
related use case is running I/O in parallel with computations in another thread.
The following code shows how the high level threading module can run tasks in background while the main
program continues to run:
11.3. Working with Binary Data Record Layouts
79
import threading, zipfile
class AsyncZip(threading.Thread):
def __init__(self, infile, outfile):
threading.Thread.__init__(self)
self.infile = infile
self.outfile = outfile
def run(self):
f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)
f.write(self.infile)
f.close()
print 'Finished background zip of: ', self.infile
background = AsyncZip('mydata.txt', 'myarchive.zip')
background.start()
print 'The main program continues to run in foreground.'
background.join()
# Wait for the background task to finish
print 'Main program waited until background was done.'
The principal challenge of multi-threaded applications is coordinating threads that share data or other resources. To
that end, the threading module provides a number of synchronization primitives including locks, events, condition
variables, and semaphores.
While those tools are powerful, minor design errors can result in problems that are difficult to reproduce. So, the
preferred approach to task coordination is to concentrate all access to a resource in a single thread and then use
the Queue module to feed that thread with requests from other threads. Applications using Queue objects for
inter-thread communication and coordination are easier to design, more readable, and more reliable.
11.5
Logging
The logging module offers a full featured and flexible logging system. At its simplest, log messages are sent to
a file or to sys.stderr:
import logging
logging.debug('Debugging information')
logging.info('Informational message')
logging.warning('Warning:config file %s not found', 'server.conf')
logging.error('Error occurred')
logging.critical('Critical error -- shutting down')
This produces the following output:
WARNING:root:Warning:config file server.conf not found
ERROR:root:Error occurred
CRITICAL:root:Critical error -- shutting down
By default, informational and debugging messages are suppressed and the output is sent to standard error. Other
output options include routing messages through email, datagrams, sockets, or to an HTTP Server. New filters can
select different routing based on message priority: DEBUG, INFO, WARNING, ERROR, and CRITICAL.
The logging system can be configured directly from Python or can be loaded from a user editable configuration
file for customized logging without altering the application.
80
Capítulo 11. Um Breve Passeio Pela Biblioteca Padrão – Parte II
11.6
Referências Fracas
Python realiza gerenciamento automático de memória (contagem de referências para a maoria dos objetos e coleta
de lixo para eliminar ciclos). A memória é liberada logo depois da última referência ser eliminada.
Essa abordagem funciona bem para a maioria das aplicações, mas ocasionalmente surge a necessidade de rastrear
objetos apenas enquanto estão sendo usados por algum outro. Infelizmente, rastreá-los através de uma referência
torna-os permanentes. O módulo weakref oferece ferramentas para rastrear objetos sem criar uma referência.
Quando o objeto não é mais necessário, ele é automaticamente removido de uma tabela de referências fracas e
uma chamada (callback) é disparada. Aplicações típicas incluem o armazenamento de objetos que são muito
dispendiosos para criar:
>>> import weakref, gc
>>> class A:
...
def __init__(self, value):
...
self.value = value
...
def __repr__(self):
...
return str(self.value)
...
>>> a = A(10)
# create a reference
>>> d = weakref.WeakValueDictionary()
>>> d['primary'] = a
# does not create a reference
>>> d['primary']
# fetch the object if it is still alive
10
>>> del a
# remove the one reference
>>> gc.collect()
# run garbage collection right away
0
>>> d['primary']
# entry was automatically removed
Traceback (most recent call last):
File "<pyshell#108>", line 1, in -toplevel-
d['primary']
# entry was automatically removed
File "C:/PY24/lib/weakref.py", line 46, in __getitem__
o = self.data[key]()
KeyError: 'primary'
11.7
Trabalhando com Listas
Muitas das necessidades envolvendo estruturas de dados podem ser alcançadas com listas. No entanto, as vezes
surge a necessidade de uma implementação alternativa, com diversos sacrifícios em nome de melhor desempenho.
O módulo array oferece um objeto array(), semelhante a uma lista, mas que armazena apenas dados ho-
mogêneos e de maneira mais compacta. O exemplo a seguir mostra um vetor de números armazenados como
números binários de dois bytes sem sinal (typecode "H") ao invés do usual 16 bytes por item nas listas normais
de objetos int:
>>> from array import array
>>> a = array('H', [4000, 10, 700, 22222])
>>> sum(a)
26932
>>> a[1:3]
array('H', [10, 700])
O módulo collections oferece um objeto deque() que comporta-se como uma lista com operações de
anexação (append()) e remoção (pop()) pelo lado esquerdo mais rápidos, mas com buscas mais lentas no centro.
Estes objetos são adequados para implementação de filas e buscas em amplitudade em árvores de dados (breadth
first tree searches):
11.6. Referências Fracas
81
>>> from collections import deque
>>> d = deque(["task1", "task2", "task3"])
>>> d.append("task4")
>>> print "Handling", d.popleft()
Handling task1
unsearched = deque([starting_node])
def breadth_first_search(unsearched):
node = unsearched.popleft()
for m in gen_moves(node):
if is_goal(m):
return m
unsearched.append(m)
Além de implementações alternativas de listas, a biblioteca também oeferece outras ferramentas como o módulo
bisect com funções para manipulações de listas ordenadas:
>>> import bisect
>>> scores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')]
>>> bisect.insort(scores, (300, 'ruby'))
>>> scores
[(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')]
O módulo heapq oferece funções para implementação de heaps baseadas em listas normais. O valor mais baixo
é sempre mantido na posição zero. Isso é útil para aplicações que acessam repetidamente o menor elemento, mas
não querem reordenar a lista toda a cada acesso:
>>> from heapq import heapify, heappop, heappush
>>> data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]
>>> heapify(data)
# rearrange the list into heap order
>>> heappush(data, -5)
# add a new entry
>>> [heappop(data) for i in range(3)] # fetch the three smallest entries
[-5, 0, 1]
11.8
Decimal Floating Point Arithmetic
The decimal module offers a Decimal datatype for decimal floating point arithmetic. Compared to the built-in
float implementation of binary floating point, the new class is especially helpful for financial applications and
other uses which require exact decimal representation, control over precision, control over rounding to meet legal
or regulatory requirements, tracking of significant decimal places, or for applications where the user expects the
results to match calculations done by hand.
For example, calculating a 5% tax on a 70 cent phone charge gives different results in decimal floating point and
binary floating point. The difference becomes significant if the results are rounded to the nearest cent:
>>> from decimal import *
>>> Decimal('0.70') * Decimal('1.05')
Decimal("0.7350")
>>> .70 * 1.05
0.73499999999999999
The Decimal result keeps a trailing zero, automatically inferring four place significance from multiplicands with
two place significance. Decimal reproduces mathematics as done by hand and avoids issues that can arise when
82
Capítulo 11. Um Breve Passeio Pela Biblioteca Padrão – Parte II
binary floating point cannot exactly represent decimal quantities.
Exact representation enables the Decimal class to perform modulo calculations and equality tests that are un-
suitable for binary floating point:
>>> Decimal('1.00') % Decimal('.10')
Decimal("0.00")
>>> 1.00 % 0.10
0.09999999999999995
>>> sum([Decimal('0.1')]*10) == Decimal('1.0')
True
>>> sum([0.1]*10) == 1.0
False
The decimal module provides arithmetic with as much precision as needed:
>>> getcontext().prec = 36
>>> Decimal(1) / Decimal(7)
Decimal("0.142857142857142857142857142857142857")
11.8. Decimal Floating Point Arithmetic
83
84
CAPÍTULO
TWELVE
E agora?
Espera-se que a leitura deste manual tenha aguçado seu interesse em utilizar Python. Agora onde você deve ir
para aprender mais ?
This tutorial is part of Python's documentation set. Some other documents in the set are:
• Python Library Reference:
You should browse through this manual, which gives complete (though terse) reference material about
types, functions, and the modules in the standard library. The standard Python distribution includes a lot
of additional code. There are modules to read U NIX mailboxes, retrieve documents via HTTP, generate
random numbers, parse command-line options, write CGI programs, compress data, and many other tasks.
Skimming through the Library Reference will give you an idea of what's available.
• Installing Python Modules explains how to install external modules written by other Python users.
• Language Reference: A detailed explanation of Python's syntax and semantics. It's heavy reading, but is
useful as a
More Python resources:
• http://www.python.org: The major Python Web site. It contains code, documentation, and pointers to Python-
related pages around the Web. This Web site is mirrored in various places around the world, such as Europe,
Japan, and Australia; a mirror may be faster than the main site, depending on your geographical location.
• http://docs.python.org: Fast access to Python's documentation.
• http://cheeseshop.python.org: The Python Package Index, nicknamed the Cheese Shop, is an index of user-
created Python modules that are available for download. Once you begin releasing code, you can register it
here so that others can find it.
• http://aspn.activestate.com/ASPN/Python/Cookbook/: The Python Cookbook is a sizable collection of code
examples, larger modules, and useful scripts. Particularly notable contributions are collected in a book also
titled Python Cookbook (O'Reilly & Associates, ISBN 0-596-00797-3.)
Para questões relacionadas a Python e notificação de problemas, você pode enviar uma mensagem para o news-
group comp.lang.python, ou para a lista de e-mail python-list@python.org. Ambos estão vinculados e tanto faz
mandar através de um ou através de outro que o resultado é o mesmo. Existem em média 120 mensagens
por dia (com picos de várias centenas), perguntando e respondendo questões, sugerindo novas funcionalidades,
e anunciando novos módulos. Antes de submeter, esteja certo que o que você procura não consta na Fre-
quently Asked Questions (também conhecida por FAQ), em http://www.python.org/doc/FAQ.html, ou procure
no diretório 'Misc/' da distribuição (código fonte). Os arquivos da lista de discussão estão disponíveis em
http://www.python.org/pipermail/. A FAQ responde muitas das questões reincidentes na lista, talvez lá esteja a
solução para o seu problema.
85
86
APÊNDICE
A
Edição de Entrada Interativa e
Substituição por Histórico
Algumas versões do interpretador Python suportam facilidades de edição e substituição semelhantes as encon-
tradas na Korn shell ou na GNU Bash shell. Isso é implementado através da biblioteca GNU Readline, que
suporta edição no estilo Emacs ou vi. Essa biblioteca possui sua própria documentação, que não será duplicada
aqui. Porém os fundamentos são fáceis de serem explicados. As facilidades aqui descritas estão disponívies nas
versões U NIX e Cygwin do interpretador.
Este capítulo não documenta as facilidades de edição do pacote PythonWin de Mark Hammond, ou do ambiente
IDLE baseado em Tk e distribuído junto com Python.
A.1
Edição de Linha
Se for suportado, edição de linha está ativa sempre que o interpretador imprimir um dos prompts (primário ou
secundário). A linha corrente pode ser editada usando comandos típicos do Emacs. Os mais imoportantes são:
C-A (Control-A) move o cursor para o início da linha, C-E para o fim, C-B move uma posição para à esquerda,
C-F para a direita. Backspace apaga o caractere à esquerda, C-D apaga o da direita. C-K apaga do cursor até o
resto da linha à direita, C-Y cola a linha apagada. C-underscore é o undo e tem efeito cumulativo.
A.2
Substituição de Histórico
Funciona da seguinte maneira: todas linhas não vazias são armazenadas em um buffer (histórico). C-P volta
uma posição no histórico, C-N avança uma posição. Pressionando Return a linha corrente é alimentada para o
interpretador. C-R inicia uma busca para trás no histórico, e C-S um busca para frente.
A.3
Vinculação de Teclas
A vinculação de teclas e outros parâmetros da biblioteca Readline podem ser personalizados por configurações
colocadas no arquivo ' ̃/.inputrc'. Vinculação de teclas tem o formato:
key-name: function-name
ou
"string": function-name
e opções podem ser especificadas com:
87
set option-name value
Por exemplo:
# Qume prefere editar estilo vi:
set editing-mode vi
# Edição em uma única linha:
set horizontal-scroll-mode On
# Redefinição de algumas teclas:
Meta-h: backward-kill-word
"\C-u": universal-argument
"\C-x\C-r": re-read-init-file
Observe que a vinculação default para Tab em Python é inserir um caractere Tab ao invés de completar o nome
de um arquivo (default no Readline). Isto pode ser reconfigurado de volta através:
Tab: complete
no ' ̃/.inputrc'. Todavia, isto torna mais difícil digitar comandos indentados em linhas de continuação se você estiver
acostumado a usar Tab para isso.
Preenchimento automático de nomes de variáveis e módulos estão opcionalmente disponívies. Para habilitá-los
no modo interativo, adicione o seguinte ao seu arquivo de inicialização: 1
import rlcompleter, readline
readline.parse_and_bind('tab: complete')
Isso vincula a tecla Tab para o preenchimento automático de nomes de função. Assim, teclar Tab duas vezes
dispara o preenchimento. Um determinado nome é procurado entre as variáveis locais e módulos disponíveis.
Para expressões terminadas em ponto, como em string.a, a expressão será avaliada até o último '.' quando
serão sugeridos possíveis extensões. Isso pode até implicar na execução de código definido por aplicação quando
um objeto que define o método __getattr__() for parte da expressão.
Um arquivo de inicialização mais eficiente seria algo como esse exemplo. Note que ele deleta os nomes que cria
quando não são mais necessários; isso é feito porque o arquivo de inicialização é executado no mesmo ambiente do
que os comandos interativos, e remover os nomes evita criar efeitos colaterais nos ambiente usado interativamente.
Você pode achar conveniente manter alguns dos módulos importados, como os, que acaba sendo necessário na
maior parte das sessões com o interpretador.
1 Python executará o conteúdo do arquivo identificado pela variável de ambiente PYTHONSTARTUP quando se dispara o interpretador
interativamente.
88
Apêndice A. Edição de Entrada Interativa e Substituição por Histórico
#
#
#
#
#
#
#
#
#
Add auto-completion and a stored history file of commands to your Python
interactive interpreter. Requires Python 2.0+, readline. Autocomplete is
bound to the Esc key by default (you can change it - see readline docs).
Store the file in ~/.pystartup, and set an environment variable to point
to it: "export PYTHONSTARTUP=/max/home/itamar/.pystartup" in bash.
Note that PYTHONSTARTUP does *not* expand "~", so you have to put in the
full path to your home directory.
import
import
import
import
atexit
os
readline
rlcompleter
historyPath = os.path.expanduser("~/.pyhistory")
def save_history(historyPath=historyPath):
import readline
readline.write_history_file(historyPath)
if os.path.exists(historyPath):
readline.read_history_file(historyPath)
atexit.register(save_history)
del os, atexit, readline, rlcompleter, save_history, historyPath
A.4
Comentário
Essa facilidade representa um enorme passo em comparação com versões anteriores do interpretador. Todavia,
ainda há características desejáveis deixadas de fora. Seria interessante se a indentação apropriada fosse sugerida
em linhas de continuação, pois o parser sabe se um token de indentação é necessário. O mecanismo de preenchi-
mento poderia utilizar a tabela de símbolos do interpretador. Também seria útil um comando para verificar (ou até
mesmo sugerir) o balanceamento de parênteses, aspas, etc.
A.4. Comentário
89
90
APÊNDICE
B
Floating Point Arithmetic: Issues and
Limitations
Floating-point numbers are represented in computer hardware as base 2 (binary) fractions. For example, the
decimal fraction
0.125
has value 1/10 + 2/100 + 5/1000, and in the same way the binary fraction
0.001
has value 0/2 + 0/4 + 1/8. These two fractions have identical values, the only real difference being that the first is
written in base 10 fractional notation, and the second in base 2.
Unfortunately, most decimal fractions cannot be represented exactly as binary fractions. A consequence is that, in
general, the decimal floating-point numbers you enter are only approximated by the binary floating-point numbers
actually stored in the machine.
The problem is easier to understand at first in base 10. Consider the fraction 1/3. You can approximate that as a
base 10 fraction:
0.3
or, better,
0.33
or, better,
0.333
and so on. No matter how many digits you're willing to write down, the result will never be exactly 1/3, but will
be an increasingly better approximation of 1/3.
In the same way, no matter how many base 2 digits you're willing to use, the decimal value 0.1 cannot be repre-
sented exactly as a base 2 fraction. In base 2, 1/10 is the infinitely repeating fraction
91
0.0001100110011001100110011001100110011001100110011...
Stop at any finite number of bits, and you get an approximation. This is why you see things like:
>>> 0.1
0.10000000000000001
On most machines today, that is what you'll see if you enter 0.1 at a Python prompt. You may not, though, because
the number of bits used by the hardware to store floating-point values can vary across machines, and Python only
prints a decimal approximation to the true decimal value of the binary approximation stored by the machine. On
most machines, if Python were to print the true decimal value of the binary approximation stored for 0.1, it would
have to display
>>> 0.1
0.1000000000000000055511151231257827021181583404541015625
instead! The Python prompt uses the builtin repr() function to obtain a string version of everything it displays.
For floats, repr(float) rounds the true decimal value to 17 significant digits, giving
0.10000000000000001
repr(float) produces 17 significant digits because it turns out that's enough (on most machines) so that
eval(repr(x)) == x exactly for all finite floats x, but rounding to 16 digits is not enough to make that
true.
Note that this is in the very nature of binary floating-point: this is not a bug in Python, it is not a bug in your code
either. You'll see the same kind of thing in all languages that support your hardware's floating-point arithmetic
(although some languages may not display the difference by default, or in all output modes).
Python's builtin str() function produces only 12 significant digits, and you may wish to use that instead. It's
unusual for eval(str(x)) to reproduce x, but the output may be more pleasant to look at:
>>> print str(0.1)
0.1
It's important to realize that this is, in a real sense, an illusion: the value in the machine is not exactly 1/10, you're
simply rounding the display of the true machine value.
Other surprises follow from this one. For example, after seeing
>>> 0.1
0.10000000000000001
you may be tempted to use the round() function to chop it back to the single digit you expect. But that makes
no difference:
>>> round(0.1, 1)
0.10000000000000001
The problem is that the binary floating-point value stored for "0.1"was already the best possible binary approxi-
mation to 1/10, so trying to round it again can't make it better: it was already as good as it gets.
92
Apêndice B. Floating Point Arithmetic: Issues and Limitations
Another consequence is that since 0.1 is not exactly 1/10, summing ten values of 0.1 may not yield exactly 1.0,
either:
>>> sum = 0.0
>>> for i in range(10):
...
sum += 0.1
...
>>> sum
0.99999999999999989
Binary floating-point arithmetic holds many surprises like this. The problem with "0.1"is explained in precise
detail below, in the "Representation Error"section. See The Perils of Floating Point for a more complete account
of other common surprises.
As that says near the end, “there are no easy answers.” Still, don't be unduly wary of floating-point! The errors in
Python float operations are inherited from the floating-point hardware, and on most machines are on the order of
no more than 1 part in 2**53 per operation. That's more than adequate for most tasks, but you do need to keep in
mind that it's not decimal arithmetic, and that every float operation can suffer a new rounding error.
While pathological cases do exist, for most casual use of floating-point arithmetic you'll see the result you expect
in the end if you simply round the display of your final results to the number of decimal digits you expect. str()
usually suffices, and for finer control see the discussion of Python's % format operator: the %g, %f and %e format
codes supply flexible and easy ways to round float results for display.
B.1
Representation Error
This section explains the “0.1” example in detail, and shows how you can perform an exact analysis of cases like
this yourself. Basic familiarity with binary floating-point representation is assumed.
Representation error refers to the fact that some (most, actually) decimal fractions cannot be represented exactly
as binary (base 2) fractions. This is the chief reason why Python (or Perl, C, C++, Java, Fortran, and many others)
often won't display the exact decimal number you expect:
>>> 0.1
0.10000000000000001
Why is that? 1/10 is not exactly representable as a binary fraction. Almost all machines today (November 2000)
use IEEE-754 floating point arithmetic, and almost all platforms map Python floats to IEEE-754 "double preci-
sion". 754 doubles contain 53 bits of precision, so on input the computer strives to convert 0.1 to the closest
fraction it can of the form J/2**N where J is an integer containing exactly 53 bits. Rewriting
1 / 10 ~= J / (2**N)
as
J ~= 2**N / 10
and recalling that J has exactly 53 bits (is >= 2**52 but < 2**53), the best value for N is 56:
B.1. Representation Error
93
>>> 2**52
4503599627370496L
>>> 2**53
9007199254740992L
>>> 2**56/10
7205759403792793L
That is, 56 is the only value for N that leaves J with exactly 53 bits. The best possible value for J is then that
quotient rounded:
>>> q, r = divmod(2**56, 10)
>>> r
6L
Since the remainder is more than half of 10, the best approximation is obtained by rounding up:
>>> q+1
7205759403792794L
Therefore the best possible approximation to 1/10 in 754 double precision is that over 2**56, or
7205759403792794 / 72057594037927936
Note that since we rounded up, this is actually a little bit larger than 1/10; if we had not rounded up, the quotient
would have been a little bit smaller than 1/10. But in no case can it be exactly 1/10!
So the computer never “sees” 1/10: what it sees is the exact fraction given above, the best 754 double approxima-
tion it can get:
>>> .1 * 2**56
7205759403792794.0
If we multiply that fraction by 10**30, we can see the (truncated) value of its 30 most significant decimal digits:
>>> 7205759403792794 * 10**30 / 2**56
100000000000000005551115123125L
meaning that the exact number stored in the computer is approximately equal to the decimal value
0.100000000000000005551115123125. Rounding that to 17 significant digits gives the 0.10000000000000001
that Python displays (well, will display on any 754-conforming platform that does best-possible input and output
conversions in its C library — yours may not!).
94
Apêndice B. Floating Point Arithmetic: Issues and Limitations
APÊNDICE
C
History and License
C.1
History of the software
Python was created in the early 1990s by Guido van Rossum at Stichting Mathematisch Centrum (CWI, see
http://www.cwi.nl/) in the Netherlands as a successor of a language called ABC. Guido remains Python's principal
author, although it includes many contributions from others.
In 1995, Guido continued his work on Python at the Corporation for National Research Initiatives (CNRI, see
http://www.cnri.reston.va.us/) in Reston, Virginia where he released several versions of the software.
In May 2000, Guido and the Python core development team moved to BeOpen.com to form the BeOpen Python-
Labs team. In October of the same year, the PythonLabs team moved to Digital Creations (now Zope Corporation;
see http://www.zope.com/). In 2001, the Python Software Foundation (PSF, see http://www.python.org/psf/) was
formed, a non-profit organization created specifically to own Python-related Intellectual Property. Zope Corpora-
tion is a sponsoring member of the PSF.
All Python releases are Open Source (see http://www.opensource.org/ for the Open Source Definition). Histori-
cally, most, but not all, Python releases have also been GPL-compatible; the table below summarizes the various
releases.
Release
0.9.0 thru 1.2
1.3 thru 1.5.2
1.6
2.0
1.6.1
2.1
2.0.1
2.1.1
2.2
2.1.2
2.1.3
2.2.1
2.2.2
2.2.3
2.3
2.3.1
2.3.2
2.3.3
2.3.4
2.3.5
2.4
2.4.1
Derived from
n/a
1.2
1.5.2
1.6
1.6
2.0+1.6.1
2.0+1.6.1
2.1+2.0.1
2.1.1
2.1.1
2.1.2
2.2
2.2.1
2.2.2
2.2.2
2.3
2.3.1
2.3.2
2.3.3
2.3.4
2.3
2.4
Year
1991-1995
1995-1999
2000
2000
2001
2001
2001
2001
2001
2002
2002
2002
2002
2002-2003
2002-2003
2002-2003
2003
2003
2004
2005
2004
2005
Owner
CWI
CNRI
CNRI
BeOpen.com
CNRI
PSF
PSF
PSF
PSF
PSF
PSF
PSF
PSF
PSF
PSF
PSF
PSF
PSF
PSF
PSF
PSF
PSF
GPL compatible?
yes
yes
no
no
no
no
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
yes
Note: GPL-compatible doesn't mean that we're distributing Python under the GPL. All Python licenses, unlike
the GPL, let you distribute a modified version without making your changes open source. The GPL-compatible
95
licenses make it possible to combine Python with other software that is released under the GPL; the others don't.
Thanks to the many outside volunteers who have worked under Guido's direction to make these releases possible.
C.2
Terms and conditions for accessing or otherwise using Python
PSF LICENSE AGREEMENT FOR PYTHON 2.4.2
1. This LICENSE AGREEMENT is between the Python Software Foundation (“PSF”), and the Individual or
Organization (“Licensee”) accessing and otherwise using Python 2.4.2 software in source or binary form
and its associated documentation.
2. Subject to the terms and conditions of this License Agreement, PSF hereby grants Licensee a nonexclusive,
royalty-free, world-wide license to reproduce, analyze, test, perform and/or display publicly, prepare deriva-
tive works, distribute, and otherwise use Python 2.4.2 alone or in any derivative version, provided, however,
that PSF's License Agreement and PSF's notice of copyright, i.e., “Copyright © 2001-2004 Python Software
Foundation; All Rights Reserved” are retained in Python 2.4.2 alone or in any derivative version prepared
by Licensee.
3. In the event Licensee prepares a derivative work that is based on or incorporates Python 2.4.2 or any part
thereof, and wants to make the derivative work available to others as provided herein, then Licensee hereby
agrees to include in any such work a brief summary of the changes made to Python 2.4.2.
4. PSF is making Python 2.4.2 available to Licensee on an “AS IS” basis. PSF MAKES NO REPRESEN-
TATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE, BUT NOT LIMI-
TATION, PSF MAKES NO AND DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MER-
CHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON
2.4.2 WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.
5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON 2.4.2 FOR ANY
INCindentaL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF MODIFY-
ING, DISTRIBUTING, OR OTHERWISE USING PYTHON 2.4.2, OR ANY DERIVATIVE THEREOF,
EVEN IF ADVISED OF THE POSSIBILITY THEREOF.
6. This License Agreement will automatically terminate upon a material breach of its terms and conditions.
7. Nothing in this License Agreement shall be deemed to create any relationship of agency, partnership, or
joint venture between PSF and Licensee. This License Agreement does not grant permission to use PSF
trademarks or trade name in a trademark sense to endorse or promote products or services of Licensee, or
any third party.
8. By copying, installing or otherwise using Python 2.4.2, Licensee agrees to be bound by the terms and
conditions of this License Agreement.
BEOPEN.COM LICENSE AGREEMENT FOR PYTHON 2.0
BEOPEN PYTHON OPEN SOURCE LICENSE AGREEMENT VERSION 1
1. This LICENSE AGREEMENT is between BeOpen.com (“BeOpen”), having an office at 160 Saratoga
Avenue, Santa Clara, CA 95051, and the Individual or Organization (“Licensee”) accessing and otherwise
using this software in source or binary form and its associated documentation (“the Software”).
2. Subject to the terms and conditions of this BeOpen Python License Agreement, BeOpen hereby grants Li-
censee a non-exclusive, royalty-free, world-wide license to reproduce, analyze, test, perform and/or display
publicly, prepare derivative works, distribute, and otherwise use the Software alone or in any derivative
version, provided, however, that the BeOpen Python License is retained in the Software, alone or in any
derivative version prepared by Licensee.
3. BeOpen is making the Software available to Licensee on an “AS IS” basis. BEOPEN MAKES NO REP-
RESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE, BUT NOT
LIMITATION, BEOPEN MAKES NO AND DISCLAIMS ANY REPRESENTATION OR WARRANTY
OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF
THE SOFTWARE WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.
96
Apêndice C. History and License
4. BEOPEN SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF THE SOFTWARE
FOR ANY INCindentaL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT
OF USING, MODIFYING OR DISTRIBUTING THE SOFTWARE, OR ANY DERIVATIVE THEREOF,
EVEN IF ADVISED OF THE POSSIBILITY THEREOF.
5. This License Agreement will automatically terminate upon a material breach of its terms and conditions.
6. This License Agreement shall be governed by and interpreted in all respects by the law of the State of
California, excluding conflict of law provisions. Nothing in this License Agreement shall be deemed to
create any relationship of agency, partnership, or joint venture between BeOpen and Licensee. This License
Agreement does not grant permission to use BeOpen trademarks or trade names in a trademark sense to
endorse or promote products or services of Licensee, or any third party. As an exception, the “BeOpen
Python” logos available at http://www.pythonlabs.com/logos.html may be used according to the permissions
granted on that web page.
7. By copying, installing or otherwise using the software, Licensee agrees to be bound by the terms and
conditions of this License Agreement.
CNRI LICENSE AGREEMENT FOR PYTHON 1.6.1
1. This LICENSE AGREEMENT is between the Corporation for National Research Initiatives, having an
office at 1895 Preston White Drive, Reston, VA 20191 (“CNRI”), and the Individual or Organization (“Li-
censee”) accessing and otherwise using Python 1.6.1 software in source or binary form and its associated
documentation.
2. Subject to the terms and conditions of this License Agreement, CNRI hereby grants Licensee a nonexclu-
sive, royalty-free, world-wide license to reproduce, analyze, test, perform and/or display publicly, prepare
derivative works, distribute, and otherwise use Python 1.6.1 alone or in any derivative version, provided,
however, that CNRI's License Agreement and CNRI's notice of copyright, i.e., “Copyright © 1995-2001
Corporation for National Research Initiatives; All Rights Reserved” are retained in Python 1.6.1 alone
or in any derivative version prepared by Licensee. Alternately, in lieu of CNRI's License Agreement,
Licensee may substitute the following text (omitting the quotes): “Python 1.6.1 is made available sub-
ject to the terms and conditions in CNRI's License Agreement. This Agreement together with Python
1.6.1 may be located on the Internet using the following unique, persistent identifier (known as a handle):
1895.22/1013. This Agreement may also be obtained from a proxy server on the Internet using the following
URL: http://hdl.handle.net/1895.22/1013.”
3. In the event Licensee prepares a derivative work that is based on or incorporates Python 1.6.1 or any part
thereof, and wants to make the derivative work available to others as provided herein, then Licensee hereby
agrees to include in any such work a brief summary of the changes made to Python 1.6.1.
4. CNRI is making Python 1.6.1 available to Licensee on an “AS IS” basis. CNRI MAKES NO REPRESEN-
TATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE, BUT NOT LIMI-
TATION, CNRI MAKES NO AND DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MER-
CHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON
1.6.1 WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.
5. CNRI SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON 1.6.1 FOR ANY
INCindentaL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF MODIFY-
ING, DISTRIBUTING, OR OTHERWISE USING PYTHON 1.6.1, OR ANY DERIVATIVE THEREOF,
EVEN IF ADVISED OF THE POSSIBILITY THEREOF.
6. This License Agreement will automatically terminate upon a material breach of its terms and conditions.
7. This License Agreement shall be governed by the federal intellectual property law of the United States, in-
cluding without limitation the federal copyright law, and, to the extent such U.S. federal law does not apply,
by the law of the Commonwealth of Virginia, excluding Virginia's conflict of law provisions. Notwithstand-
ing the foregoing, with regard to derivative works based on Python 1.6.1 that incorporate non-separable
material that was previously distributed under the GNU General Public License (GPL), the law of the Com-
monwealth of Virginia shall govern this License Agreement only as to issues arising under or with respect
to Paragraphs 4, 5, and 7 of this License Agreement. Nothing in this License Agreement shall be deemed to
C.2. Terms and conditions for accessing or otherwise using Python
97
create any relationship of agency, partnership, or joint venture between CNRI and Licensee. This License
Agreement does not grant permission to use CNRI trademarks or trade name in a trademark sense to endorse
or promote products or services of Licensee, or any third party.
8. By clicking on the “ACCEPT” button where indicated, or by copying, installing or otherwise using Python
1.6.1, Licensee agrees to be bound by the terms and conditions of this License Agreement.
ACCEPT
CWI LICENSE AGREEMENT FOR PYTHON 0.9.0 THROUGH 1.2
Copyright © 1991 - 1995, Stichting Mathematisch Centrum Amsterdam, The Netherlands. All rights reserved.
Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee
is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice
and this permission notice appear in supporting documentation, and that the name of Stichting Mathematisch
Centrum or CWI not be used in advertising or publicity pertaining to distribution of the software without specific,
written prior permission.
STICHTING MATHEMATISCH CENTRUM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
EVENT SHALL STICHTING MATHEMATISCH CENTRUM BE LIABLE FOR ANY SPECIAL, INDIRECT
OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TOR-
TIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.
C.3
Licenses and Acknowledgements for Incorporated Software
This section is an incomplete, but growing list of licenses and acknowledgements for third-party software incor-
porated in the Python distribution.
C.3.1 Mersenne Twister
The _random module includes code based on a download from http://www.math.keio.ac.jp/ matu-
moto/MT2002/emt19937ar.html. The following are the verbatim comments from the original code:
98
Apêndice C. History and License
A C-program for MT19937, with initialization improved 2002/1/26.
Coded by Takuji Nishimura and Makoto Matsumoto.
Before using, initialize the state by using init_genrand(seed)
or init_by_array(init_key, key_length).
Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
3. The names of its contributors may not be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCindentaL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
Any feedback is very welcome.
http://www.math.keio.ac.jp/matumoto/emt.html
email: matumoto@math.keio.ac.jp
C.3.2 Sockets
The socket module uses the functions, getaddrinfo, and getnameinfo, which are coded in separate
source files from the WIDE Project, http://www.wide.ad.jp/about/index.html.
C.3. Licenses and Acknowledgements for Incorporated Software
99
Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
3. Neither the name of the project nor the names of its contributors
may be used to endorse or promote products derived from this software
without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ''AS IS'' AND
GAI_ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
FOR GAI_ANY DIRECT, INDIRECT, INCindentaL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON GAI_ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN GAI_ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
C.3.3 Floating point exception control
The source for the fpectl module includes the following notice:
100
Apêndice C. History and License
---------------------------------------------------------------------
Copyright (c) 1996.
\
|
The Regents of the University of California.
|
|
All rights reserved.
|
|
|
|
Permission to use, copy, modify, and distribute this software for
|
|
any purpose without fee is hereby granted, provided that this en-
|
|
tire notice is included in all copies of any software which is or
|
|
includes a copy or modification of this software and in all
|
|
copies of the supporting documentation for such software.
|
|
|
|
This work was produced at the University of California, Lawrence
|
|
Livermore National Laboratory under contract no. W-7405-ENG-48
|
|
between the U.S. Department of Energy and The Regents of the
|
|
University of California for the operation of UC LLNL.
|
|
|
|
DISCLAIMER
|
|
|
|
This software was prepared as an account of work sponsored by an
|
|
agency of the United States Government. Neither the United States
|
|
Government nor the University of California nor any of their em-
|
|
ployees, makes any warranty, express or implied, or assumes any
|
|
liability or responsibility for the accuracy, completeness, or
|
|
usefulness of any information, apparatus, product, or process
|
|
disclosed,
or represents that its use would not infringe
|
|
privately-owned rights. Reference herein to any specific commer-
|
|
cial products, process, or service by trade name, trademark,
|
|
manufacturer, or otherwise, does not necessarily constitute or
|
|
imply its endorsement, recommendation, or favoring by the United
|
|
States Government or the University of California. The views and
|
|
opinions of authors expressed herein do not necessarily state or
|
|
reflect those of the United States Government or the University
|
|
of California, and shall not be used for advertising or product
|
\ endorsement purposes.
/
---------------------------------------------------------------------
/
C.3.4 MD5 message digest algorithm
The source code for the md5 module contains the following notice:
C.3. Licenses and Acknowledgements for Incorporated Software
101
Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.
License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.
License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.
RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.
These notices must be retained in any copies of any part of this
documentation and/or software.
C.3.5 Asynchronous socket services
The asynchat and asyncore modules contain the following notice:
Copyright 1996 by Sam Rushing
All Rights Reserved
Permission to use, copy, modify, and distribute this software and
its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all
copies and that both that copyright notice and this permission
notice appear in supporting documentation, and that the name of Sam
Rushing not be used in advertising or publicity pertaining to
distribution of the software without specific, written prior
permission.
SAM RUSHING DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
NO EVENT SHALL SAM RUSHING BE LIABLE FOR ANY SPECIAL, INDIRECT OR
CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
C.3.6 Cookie management
The Cookie module contains the following notice:
102
Apêndice C. History and License
Copyright 2000 by Timothy O'Malley <timo@alum.mit.edu>
All Rights Reserved
Permission to use, copy, modify, and distribute this software
and its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all
copies and that both that copyright notice and this permission
notice appear in supporting documentation, and that the name of
Timothy O'Malley not be used in advertising or publicity
pertaining to distribution of the software without specific, written
prior permission.
Timothy O'Malley DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL Timothy O'Malley BE LIABLE FOR
ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
C.3.7 Profiling
The profile and pstats modules contain the following notice:
Copyright 1994, by InfoSeek Corporation, all rights reserved.
Written by James Roskind
Permission to use, copy, modify, and distribute this Python software
and its associated documentation for any purpose (subject to the
restriction in the following sentence) without fee is hereby granted,
provided that the above copyright notice appears in all copies, and
that both that copyright notice and this permission notice appear in
supporting documentation, and that the name of InfoSeek not be used in
advertising or publicity pertaining to distribution of the software
without specific, written prior permission. This permission is
explicitly restricted to the copying and modification of the software
to remain in Python, compiled Python, or other languages (such as C)
wherein the modified or derived code is exclusively imported into a
Python module.
INFOSEEK CORPORATION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL INFOSEEK CORPORATION BE LIABLE FOR ANY
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
C.3.8 Execution tracing
The trace module contains the following notice:
C.3. Licenses and Acknowledgements for Incorporated Software
103
portions copyright 2001, Autonomous Zones Industries, Inc., all rights...
err... reserved and offered to the public under the terms of the
Python 2.2 license.
Author: Zooko O'Whielacronx
http://zooko.com/
mailto:zooko@zooko.com
Copyright 2000, Mojam Media, Inc., all rights reserved.
Author: Skip Montanaro
Copyright 1999, Bioreason, Inc., all rights reserved.
Author: Andrew Dalke
Copyright 1995-1997, Automatrix, Inc., all rights reserved.
Author: Skip Montanaro
Copyright 1991-1995, Stichting Mathematisch Centrum, all rights reserved.
Permission to use, copy, modify, and distribute this Python software and
its associated documentation for any purpose without fee is hereby
granted, provided that the above copyright notice appears in all copies,
and that both that copyright notice and this permission notice appear in
supporting documentation, and that the name of neither Automatrix,
Bioreason or Mojam Media be used in advertising or publicity pertaining to
distribution of the software without specific, written prior permission.
C.3.9 UUencode and UUdecode functions
The uu module contains the following notice:
Copyright 1994 by Lance Ellinghouse
Cathedral City, California Republic, United States of America.
All Rights Reserved
Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Lance Ellinghouse
not be used in advertising or publicity pertaining to distribution
of the software without specific, written prior permission.
LANCE ELLINGHOUSE DISCLAIMS ALL WARRANTIES WITH REGARD TO
THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS, IN NO EVENT SHALL LANCE ELLINGHOUSE CENTRUM BE LIABLE
FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
Modified by Jack Jansen, CWI, July 1995:
- Use binascii module to do the actual line-by-line conversion
between ascii and binary. This results in a 1000-fold speedup. The C
version is still 5 times faster, though.
- Arguments more compliant with python standard
104
Apêndice C. History and License
C.3.10 XML Remote Procedure Calls
The xmlrpclib module contains the following notice:
The XML-RPC client interface is
Copyright (c) 1999-2002 by Secret Labs AB
Copyright (c) 1999-2002 by Fredrik Lundh
By obtaining, using, and/or copying this software and/or its
associated documentation, you agree that you have read, understood,
and will comply with the following terms and conditions:
Permission to use, copy, modify, and distribute this software and
its associated documentation for any purpose and without fee is
hereby granted, provided that the above copyright notice appears in
all copies, and that both that copyright notice and this permission
notice appear in supporting documentation, and that the name of
Secret Labs AB or the author not be used in advertising or publicity
pertaining to distribution of the software without specific, written
prior permission.
SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-
ABILITY AND FITNESS. IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR
BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
OF THIS SOFTWARE.
C.3. Licenses and Acknowledgements for Incorporated Software
105
106
APÊNDICE
D
Glossary
>>> The typical Python prompt of the interactive shell. Often seen for code examples that can be tried right away
in the interpreter.
... The typical Python prompt of the interactive shell when entering code for an indented code block.
BDFL Benevolent Dictator For Life, a.k.a. Guido van Rossum, Python's creator.
byte code The internal representation of a Python program in the interpreter. The byte code is also cached in
.pyc and .pyo files so that executing the same file is faster the second time (recompilation from source to
byte code can be avoided). This “intermediate language” is said to run on a “virtual machine” that calls the
subroutines corresponding to each bytecode.
classic class Any class which does not inherit from object. See new-style class.
coercion The implicit conversion of an instance of one type to another during an operation which involves two
arguments of the same type. For example, int(3.15) converts the floating point number to the inte-
ger 3, but in 3+4.5, each argument is of a different type (one int, one float), and both must be con-
verted to the same type before they can be added or it will raise a TypeError. Coercion between
two operands can be performed with the coerce builtin function; thus, 3+4.5 is equivalent to calling
operator.add(*coerce(3, 4.5)) and results in operator.add(3.0, 4.5). Without co-
ercion, all arguments of even compatible types would have to be normalized to the same value by the
programmer, e.g., float(3)+4.5 rather than just 3+4.5.
complex number An extension of the familiar real number system in which all numbers are expressed as a sum
of a real part and an imaginary part. Imaginary numbers are real multiples of the imaginary unit (the square
root of -1), often written i in mathematics or j in engineering. Python has builtin support for complex
numbers, which are written with this latter notation; the imaginary part is written with a j suffix, e.g., 3+1j.
To get access to complex equivalents of the math module, use cmath. Use of complex numbers is a fairly
advanced mathematical feature. If you're not aware of a need for them, it's almost certain you can safely
ignore them.
descriptor Any new-style object that defines the methods __get__(), __set__(), or __delete__().
When a class attribute is a descriptor, its special binding behavior is triggered upon attribute lookup. Nor-
mally, writing a.b looks up the object b in the class dictionary for a, but if b is a descriptor, the defined
method gets called. Understanding descriptors is a key to a deep understanding of Python because they
are the basis for many features including functions, methods, properties, class methods, static methods, and
reference to super classes.
dictionary An associative array, where arbitrary keys are mapped to values. The use of dict much resembles
that for list, but the keys can be any object with a __hash__() function, not just integers starting from
zero. Called a hash in Perl.
duck-typing Pythonic programming style that determines an object's type by inspection of its method or at-
tribute signature rather than by explicit relationship to some type object ("If it looks like a duck and quacks
like a duck, it must be a duck.") By emphasizing interfaces rather than specific types, well-designed code
improves its flexibility by allowing polymorphic substitution. Duck-typing avoids tests using type() or
isinstance(). Instead, it typically employs hasattr() tests or EAFP programming.
107
EAFP Easier to ask for forgiveness than permission. This common Python coding style assumes the existence
of valid keys or attributes and catches exceptions if the assumption proves false. This clean and fast style
is characterized by the presence of many try and except statements. The technique contrasts with the
LBYL style that is common in many other languages such as C.
__future__ A pseudo module which programmers can use to enable new language features which are not compat-
ible with the current interpreter. For example, the expression 11/4 currently evaluates to 2. If the module
in which it is executed had enabled true division by executing:
from __future__ import division
the expression 11/4 would evaluate to 2.75. By importing the __future__ module and evaluating its
variables, you can see when a new feature was first added to the language and when it will become the
default:
>>> import __future__
>>> __future__.division
_Feature((2, 2, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0), 8192)
generator A function that returns an iterator. It looks like a normal function except that values are returned to the
caller using a yield statement instead of a return statement. Generator functions often contain one or
more for or while loops that yield elements back to the caller. The function execution is stopped at the
yield keyword (returning the result) and is resumed there when the next element is requested by calling
the next() method of the returned iterator.
generator expression An expression that returns a generator. It looks like a normal expression followed by a
for expression defining a loop variable, range, and an optional if expression. The combined expression
generates values for an enclosing function:
>>> sum(i*i for i in range(10))
285
# sum of squares 0, 1, 4, ... 81
GIL See global interpreter lock.
global interpreter lock The lock used by Python threads to assure that only one thread can be run at a time.
This simplifies Python by assuring that no two processes can access the same memory at the same time.
Locking the entire interpreter makes it easier for the interpreter to be multi-threaded, at the expense of some
parallelism on multi-processor machines. Efforts have been made in the past to create a “free-threaded” in-
terpreter (one which locks shared data at a much finer granularity), but performance suffered in the common
single-processor case.
IDLE An Integrated Development Environment for Python. IDLE is a basic editor and interpreter environment
that ships with the standard distribution of Python. Good for beginners, it also serves as clear example code
for those wanting to implement a moderately sophisticated, multi-platform GUI application.
immutable An object with fixed value. Immutable objects are numbers, strings or tuples (and more). Such an
object cannot be altered. A new object has to be created if a different value has to be stored. They play an
important role in places where a constant hash value is needed, for example as a key in a dictionary.
integer division Mathematical division discarding any remainder. For example, the expression 11/4 currently
evaluates to 2 in contrast to the 2.75 returned by float division. Also called floor division. When dividing
two integers the outcome will always be another integer (having the floor function applied to it). However,
if one of the operands is another numeric type (such as a float), the result will be coerced (see coercion)
to a common type. For example, an integer divided by a float will result in a float value, possibly with a
decimal fraction. Integer division can be forced by using the // operator instead of the / operator. See also
__future__.
interactive Python has an interactive interpreter which means that you can try out things and immediately see
their results. Just launch python with no arguments (possibly by selecting it from your computer's main
108
Apêndice D. Glossary
menu). It is a very powerful way to test out new ideas or inspect modules and packages (remember
help(x)).
interpreted Python is an interpreted language, as opposed to a compiled one. This means that the source files
can be run directly without first creating an executable which is then run. Interpreted languages typically
have a shorter development/debug cycle than compiled ones, though their programs generally also run more
slowly. See also interactive.
iterable A container object capable of returning its members one at a time. Examples of iterables include all
sequence types (such as list, str, and tuple) and some non-sequence types like dict and file and
objects of any classes you define with an __iter__() or __getitem__() method. Iterables can be
used in a for loop and in many other places where a sequence is needed (zip(), map(), ...). When an
iterable object is passed as an argument to the builtin function iter(), it returns an iterator for the object.
This iterator is good for one pass over the set of values. When using iterables, it is usually not necessary
to call iter() or deal with iterator objects yourself. The for statement does that automatically for you,
creating a temporary unnamed variable to hold the iterator for the duration of the loop. See also iterator,
sequence, and generator.
iterator An object representing a stream of data. Repeated calls to the iterator's next() method return suc-
cessive items in the stream. When no more data is available a StopIteration exception is raised
instead. At this point, the iterator object is exhausted and any further calls to its next() method just raise
StopIteration again. Iterators are required to have an __iter__() method that returns the iterator
object itself so every iterator is also iterable and may be used in most places where other iterables are ac-
cepted. One notable exception is code that attempts multiple iteration passes. A container object (such as
a list) produces a fresh new iterator each time you pass it to the iter() function or use it in a for
loop. Attempting this with an iterator will just return the same exhausted iterator object used in the previous
iteration pass, making it appear like an empty container.
LBYL Look before you leap. This coding style explicitly tests for pre-conditions before making calls or lookups.
This style contrasts with the EAFP approach and is characterized by the presence of many if statements.
list comprehension A compact way to process all or a subset of elements in a sequence and return a list with the
results. result = ["0x%02x"%x for x in range(256) if x %2 == 0] generates a list of
strings containing hex numbers (0x..) that are even and in the range from 0 to 255. The if clause is optional.
If omitted, all elements in range(256) are processed.
mapping A container object (such as dict) that supports arbitrary key lookups using the special method __-
getitem__().
metaclass The class of a class. Class definitions create a class name, a class dictionary, and a list of base classes.
The metaclass is responsible for taking those three arguments and creating the class. Most object oriented
programming languages provide a default implementation. What makes Python special is that it is possible
to create custom metaclasses. Most users never need this tool, but when the need arises, metaclasses can
provide powerful, elegant solutions. They have been used for logging attribute access, adding thread-safety,
tracking object creation, implementing singletons, and many other tasks.
mutable Mutable objects can change their value but keep their id(). See also immutable.
namespace The place where a variable is stored. Namespaces are implemented as dictionaries. There are
the local, global and builtin namespaces as well as nested namespaces in objects (in methods). Names-
paces support modularity by preventing naming conflicts. For instance, the functions __builtin_-
_.open() and os.open() are distinguished by their namespaces. Namespaces also aid readabil-
ity and maintainability by making it clear which module implements a function. For instance, writing
random.seed() or itertools.izip() makes it clear that those functions are implemented by the
random and itertools modules respectively.
nested scope The ability to refer to a variable in an enclosing definition. For instance, a function defined inside
another function can refer to variables in the outer function. Note that nested scopes work only for reference
and not for assignment which will always write to the innermost scope. In contrast, local variables both read
and write in the innermost scope. Likewise, global variables read and write to the global namespace.
109
new-style class Any class that inherits from object. This includes all built-in types like list and dict.
Only new-style classes can use Python's newer, versatile features like __slots__, descriptors, properties,
__getattribute__(), class methods, and static methods.
Python3000 A mythical python release, not required to be backward compatible, with telepathic interface.
__slots__ A declaration inside a new-style class that saves memory by pre-declaring space for instance attributes
and eliminating instance dictionaries. Though popular, the technique is somewhat tricky to get right and is
best reserved for rare cases where there are large numbers of instances in a memory-critical application.
sequence An iterable which supports efficient element access using integer indices via the __getitem__()
and __len__() special methods. Some built-in sequence types are list, str, tuple, and unicode.
Note that dict also supports __getitem__() and __len__(), but is considered a mapping rather
than a sequence because the lookups use arbitrary immutable keys rather than integers.
Zen of Python Listing of Python design principles and philosophies that are helpful in understanding and using
the language. The listing can be found by typing “import this” at the interactive prompt.
110
Apêndice D. Glossary
ÍNDICE REMISSIVO
Symbols
..., 107
»>, 107
__all__, 45
__builtin__ (built-in module), 42
__future__, 108
__slots__, 110
A
append() (list method), 29
B
BDFL, 107
byte code, 107
C
classic class, 107
coercion, 107
compileall (standard module), 41
complex number, 107
count() (list method), 29
generator expression, 108
GIL, 108
global interpreter lock, 108
H
help() (built-in function), 71
I
IDLE, 108
immutable, 108
index() (list method), 29
insert() (list method), 29
integer division, 108
interactive, 108
interpreted, 109
iterable, 109
iterator, 109
L
LBYL, 109
list comprehension, 109
D M
descriptor, 107 mapping, 109
dictionary, 107 metaclass, 109
docstrings, 21, 26 method
documentation strings, 26 object, 62
duck-typing, 107 module
                search path, 40
               mutable, 109
E
EAFP, 107
environment variables
PATH, 5, 40
PYTHONPATH, 40, 42
PYTHONSTARTUP, 6, 88
extend() (list method), 29
F
file
object, 49
for
statement, 19
G
generator, 108
N
namespace, 109
nested scope, 109
new-style class, 109
O
object
file, 49
method, 62
open() (built-in function), 49
P
PATH, 5, 40
path
111
module search, 40
pickle (standard module), 51
pop() (list method), 29
Python3000, 110
PYTHONPATH, 40, 42
PYTHONSTARTUP, 6, 88
R
readline (built-in module), 88
remove() (list method), 29
reverse() (list method), 29
rlcompleter (standard module), 88
S
search
path, module, 40
sequence, 110
sort() (list method), 29
statement
for, 19
string (standard module), 47
strings, documentation, 26
strings,documentation, 21
sys (standard module), 41
U
unicode() (built-in function), 14
Z
Zen of Python, 110
112
Índice Remissivo

